{"actions.md":{"id":"actions.md","title":"Application state - Actions","url":"/app-state/actions/","excerpt":"Actions\n\nIt is common to be able to call a method and perform an action. To achieve this, you can define methods when creating...","body":"Actions\n\nIt is common to be able to call a method and perform an action. To achieve this, you can define methods when creating your store.\nMethods are functions that can be defined anywhere in the store definition object.\n\nconst store = createAppState('example.store', {\n  initialState: {\n    someData: null\n  },\n  someAction () {\n    // perform some action\n  },\n  someOtherAction () {\n    // perform another action\n  }\n})\n\nEach action is invoked in the context of the store which means this refers to the store instance.\n\nconst store = createAppState('example.store', {\n  initialState: {\n    someData: null\n  },\n  someAction () {\n    doSomeDataLoading()\n      .then(data => {\n        // call the setState method to mutate the state\n        this.setState(state => ({ ...state, someData: data }))\n      })\n  }\n})\n\nActions can contain async operations such as fetching data.\n\nThe end-goal of an action can either be committing one or more state changes or returning filtered state."},"clearing.md":{"id":"clearing.md","title":"Application state - Clearing the store","url":"/app-state/clearing/","excerpt":"Clearing the store\n\nTo clear a store and reset back to the initial state, use the clear() method.\n\n// An initialised store....","body":"Clearing the store\n\nTo clear a store and reset back to the initial state, use the clear() method.\n\n// An initialised store. Params omitted for brevity\nconst store = createAppState('an.example.store', {\n  ...\n})\n\n// clear the store and reset back to the initial state\nstore.clear()\n\n// you can also clear without notifying subscribers\nstore.clear(false)"},"create-app-state.md":{"id":"create-app-state.md","title":"Application state - createAppState function","url":"/app-state/create-app-state/","excerpt":"createAppState function\n\nWhen using the createAppState function, you must pass two parameters:\n\nstore key (for example...","body":"createAppState function\n\nWhen using the createAppState function, you must pass two parameters:\n\nstore key (for example an.example.store) - keys must be unique and are used to retrieve stores later\nan object that defines the properties of the store\n\nThe following properties are used when creating stores:\n\nProperty Type Description\ninitialState object The initial state of the store\npersist string or object If persistence is required (between reloads), provide a unique namespace string for saving the store to window.sessionStorage\nttl number Limit the lifetime of the data in the store by setting a time to live in milliseconds. Once the amount of milliseconds has elapsed, the store resets back to the initialState values\n* function one or more action functions that are invoked to eventually mutate state\n\nconst store = createAppState('an.example.store', {\n  initialState: {\n    count: 0\n  },\n  persist: 'an.example.store',\n  ttl: 3600000, // 1 hour\n  increment (payload) {\n    this.state.count = this.state.count + payload\n  }\n})"},"example.md":{"id":"example.md","title":"Router - Example","url":"/router/example/","excerpt":"Example\n\nImport the router creator function into your Javascript main file:\n\nmain.js\n\n// import the createRouter function\nimport...","body":"Example\n\nImport the router creator function into your Javascript main file:\n\nmain.js\n\n// import the createRouter function\nimport { createRouter } from 'https://cdn.skypack.dev/@ficusjs/router@3'\n\n// create list of routes\nconst routes = [\n  { path: '/one', component: 'page-one' },\n  { path: '/two', component: 'page-two' }\n]\n\n// Create a new router instance using the element selector as the router outlet\nconst router = createRouter(routes, '#router-outlet')"},"get-app-state.md":{"id":"get-app-state.md","title":"Application state - getAppState function","url":"/app-state/get-app-state/","excerpt":"getAppState function\n\nThe getAppState function is a quick way to retrieve a store.\n\n// import the function\nimport { getAppState...","body":"getAppState function\n\nThe getAppState function is a quick way to retrieve a store.\n\n// import the function\nimport { getAppState } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// retrieve a store instance\nconst storeInstance = getAppState('my.another.store')"},"index.md":{"id":"index.md","title":"Finite state machines and statecharts","url":"/state-machines/index/","excerpt":"Finite state machines and statecharts\n\nFicusJS provides a set of functions for extending components to use finite state machines...","body":"Finite state machines and statecharts\n\nFicusJS provides a set of functions for extending components to use finite state machines and statecharts.\n\nWhat is a finite state machine?\n\nA finite state machine is an alternative way of modeling program state; instead of defining independent variables, a machine is crafted specifically to handle what states are possible, and when a machine is a given state, what next state is allowed.\n\nWhat are statecharts?\n\nStatecharts are the \"bigger brother\" of state machines, designed to overcome the limitations of state machines. A statechart is essentially a state machine that allows any state to include more machines, in a hierarchical fashion.\n\nFind out more\n\nYou can find out more about state machines and statecharts at https://statecharts.dev"},"multiple.md":{"id":"multiple.md","title":"Application state - Multiple stores","url":"/app-state/multiple/","excerpt":"Multiple stores\n\nYou can create as many stores as you want to separate your application state.\n\nManage multiple store instances...","body":"Multiple stores\n\nYou can create as many stores as you want to separate your application state.\n\nManage multiple store instances with an object\n\nSimply create a Javascript Object containing multiple store instances and then pass specific instances to your components.\n\nYou can also pass this object to a component and have it reacting to all store instances.\n\n// Create a number of stores\nconst allStores = {\n  food: createAppState('my.food.store', { ... }),\n  drinks: createAppState('my.drinks.store', { ... }),\n  snacks: createAppState('my.snacks.store', { ... })\n}\n\n// Pass a relevant store to a component\ncreateCustomElement(\n  'my-component',\n  withStore(allStores.drinks, {\n    ...\n  })\n)\n\n// Or pass all the stores to a component\ncreateCustomElement(\n  'my-component',\n  withStore(allStores, {\n    ...\n  })\n)\n\n// Or just pass the required stores to a component\ncreateCustomElement(\n  'my-component',\n  withStore({\n    food: allStores.food,\n    snacks: allStores.snacks\n  }, {\n    ...\n  })\n)\n\nClearing multiple stores\n\nYou can clear multiple stores using custom methods.\n\n// A helper function for testing a store instance\nfunction isStore (store) {\n  return store.subscribe && typeof store.subscribe === 'function'\n}\n\n// Create a number of stores\nconst allStores = {\n  food: createAppState('my.food.store', { ... }),\n  drinks: createAppState('my.drinks.store', { ... }),\n  snacks: createAppState('my.snacks.store', { ... }),\n  clear (notifySubscribers = true) {\n    Object.values(this).forEach(v => isStore(v) && v.clear(notifySubscribers))\n  }\n}"},"persistence.md":{"id":"persistence.md","title":"Application state - Persistence","url":"/app-state/persistence/","excerpt":"Persistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will...","body":"Persistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will re-hydrate your store on initialisation.\n\n// An initialised store. Params omitted for brevity\nconst store = createAppState('an.example.store', {\n  persist: 'food' // this must be a unique namespace for the store\n})\n\ncreatePersist function\n\nYou can optionally save state to window.localStorage (for persistence across browser sessions) using the createPersist function:\n\nimport { createAppState, createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// An initialised store. Params omitted for brevity\nconst store = createAppState('an.example.store', {\n  persist: createPersist('food', 'local')\n})\n\nWhen using the createPersist function, the following arguments must be supplied:\n\nArgument Type Required Description\nnamespace string true The unique namespace for the store\nstorage string true The storage mechanism to use - either local for window.localStorage or session for window.sessionStorage (default)\noptions object  Persistence options. See options below.\n\nOptions\n\nOptions can be provided when creating persistence.\n\nimport { createAppState, createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// An initialised store. Params omitted for brevity\nconst store = createAppState('an.example.store', {\n  initialState: {\n    count: 0,\n    currentRun: 0\n  },\n  persist: createPersist('food', 'local', {\n    clearOnReload: true,\n    saveState (state) {\n      return {\n        count: state.count\n      }\n    }\n  })\n})\n\noptions.clearOnReload\n\nSetting options.clearOnReload to true will detect the browser reload state using\nthe window.performance API and clear the persistence\nif a reload type is detected.\n\ncreatePersist('food', 'local', {\n  clearOnReload: true\n})\n\noptions.saveState\n\nSetting options.saveState provides a way to persist specific data different to that of the store state.\nThis is useful when the store state contains functions or other data that cannot be serialised into a string when saved\nto window.sessionStorage or window.localStorage.\n\ncreatePersist('food', 'local', {\n  saveState (state) {\n    return {\n      // return properties of state to persist\n    }\n  }\n})\n\nThe saveState function is passed the current state and must return an object of data to be serialised into a string.\n\nCustom persistence\n\nYou can provide a custom class and persist your application state in whichever way you choose.\n\nFour methods must be implemented:\n\nMethod Description\nsetState(state) Save the state in the persistence store\ngetState() Retrieve the state from the persistence store\nlastUpdated() Retrieve the last updated time of the state in milliseconds since the Unix Epoch\nremoveState() Remove the state from the persistence store\n\nimport { createAppState } from 'https://cdn.skypack.dev/ficusjs@6'\n\nclass MyCustomPersist {\n  setState (state) {\n    // set the state\n  }\n\n  getState () {\n    // get the state\n  }\n\n  lastUpdated () {\n    // get the last updated time in milliseconds since the Unix Epoch\n  }\n\n  removeState () {\n    // remove the state - this is called by default when setState is null\n  }\n}\n\n// An initialised store. Params omitted for brevity\nconst store = createAppState('an.example.store', {\n  persist: new MyCustomPersist()\n})"},"singleton.md":{"id":"singleton.md","title":"Application state - Singleton store","url":"/app-state/singleton/","excerpt":"Singleton store\n\nIf you want a single instance of a store without having to pass variables around, you can use the singleton...","body":"Singleton store\n\nIf you want a single instance of a store without having to pass variables around, you can use the singleton pattern to create an instance that can be imported into individual files.\nSimply export a const and it will be treated as a singleton.\n\n// create a single singleton store\nexport const store = createAppState('an.example.store', { ... })\n\n// create multiple stores in a singleton\nexport const allStores = {\n  food: createAppState('my.food.store', { ... }),\n  drinks: createAppState('my.drinks.store', { ... }),\n  snacks: createAppState('my.snacks.store', { ... })\n}"},"state.md":{"id":"state.md","title":"Components - State","url":"/components/state/","excerpt":"State\n\nState in components can be implemented using a number of patterns and functions.\n\nLocal state\n\nLocal state is private to...","body":"State\n\nState in components can be implemented using a number of patterns and functions.\n\nLocal state\n\nLocal state is private to a component. It is a set of independent variables in a component and their values at any point in time.\n\nChanging state triggers a re-evaluation of the variables causing a render of the component.\n\nComponents created with the createCustomElement function can be extended to include local state using the withLocalState function.\n\nIf creating components using the createComponent function, local state is automatically provided.\n\nState machines and statecharts\n\nA finite state machine is an alternative way of modeling component state; instead of defining independent variables, a machine is crafted specifically to handle what states are possible, and when a machine is a given state, what next state is allowed.\n\nStatecharts are the \"bigger brother\" of state machines, designed to overcome the limitations of state machines. A statechart is essentially a state machine that allows any state to include more machines, in a hierarchical fashion.\n\nComponents created with the createCustomElement function can be extended to include a lightweight state machine using the withStateMachine function.\n\nXState is a library for creating, interpreting, and executing finite state machines and statecharts, as well as managing invocations of those machines as actors.\nComponents can be extended to integrate interpreted statecharts (known as a service) using the withXStateService function.\n\nApplication state\n\nApplication state is referred to as a store. It is a set of independent variables, and their values at any point in time created globally and shared across multiple components.\n\nChanging application state notifies any components listening for changes causing a render of those components.\n\nCreating stores for application state is done using the createAppState function.\nComponents can be extended to listen for store changes using the withStore function."},"subscribe.md":{"id":"subscribe.md","title":"Event bus - Subscribe","url":"/event-bus/subscribe/","excerpt":"Subscribe\n\nTo be notified when a particular topic is published, use the subscribe method to register a callback function.\nThis...","body":"Subscribe\n\nTo be notified when a particular topic is published, use the subscribe method to register a callback function.\nThis method returns a function which can be invoked later for unsubscription.\n\nconst unsubscribe = eventBus.subscribe('myTopic', data => {\n  // handle the event with the data passed\n})\n\n// Unsubscribe later\nunsubscribe()\n\nOptions\n\nOptions can be passed to the subscribe function to customise the behaviour of the subscriber.\n\nconst options = {\n  fireOnce: true\n}\n\nconst unsubscribe = eventBus.subscribe('myTopic', data => {\n  // handle the event with the data passed\n}, options)\n\nThe supported options are:\n\nProperty Type Default Description\nfireOnce boolean false Set to true for the subscriber to be notified just once"},"usage.md":{"id":"usage.md","title":"I18n - Usage in components","url":"/i18n/usage/","excerpt":"Usage in components\n\nOnce you have created the i18n instance, the withI18n function extends a component and makes working with...","body":"Usage in components\n\nOnce you have created the i18n instance, the withI18n function extends a component and makes working with i18n easier in component methods.\n\nSee extending components for more on the withI18n function.\n\nimport { createCustomElement, createI18n, withI18n } from 'https://cdn.skypack.dev/ficusjs@6'\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// create the i18n instance\nconst i18n = createI18n()\n\n// change interpolation delimiters\ni18n.interpolateWith(/\\$(\\w+)/g)\n\n// populate the messages\ni18n.add({\n    projectTitle: 'Project title',\n    button: {\n        text: 'Click me $userName!',\n        caption: 'Please click me!'\n    },\n    itemsCaption: [\n        '$count item',\n        '$count items'\n    ],\n    deep: {\n        nested: {\n            label: 'Deep nested label'\n        }\n    }\n})\n\n// Use the i18n instance in a new component\ncreateCustomElement(\n  'i18n-messages',\n  withI18n(i18n, {\n    renderer,\n    render () {\n      return html`\n        i18n messages\n        \n          Title\n          ${this.i18n.t('projectTitle')}\n          Button text\n          ${this.i18n.t('button.text', { userName: 'George' })}\n          Button caption\n          ${this.i18n.t('button.caption')}\n          Items caption\n          ${this.i18n.t('itemsCaption', { count: 0 })}\n          ${this.i18n.t('itemsCaption', { count: 1 })}\n          ${this.i18n.t('itemsCaption', { count: 2 })}\n          Deep nested label\n          ${this.i18n.t('deep.nested.label')}\n        \n      `\n    }\n  })\n)\n\nAlternatively, fork this Codepen to see it in action - https://codepen.io/ducksoupdev/pen/gOQeERm"},"web-workers.md":{"id":"web-workers.md","title":"Application state - Web workers","url":"/app-state/web-workers/","excerpt":"Web workers\n\nWeb workers can be an important and useful tool in keeping your app smooth and responsive by preventing any...","body":"Web workers\n\nWeb workers can be an important and useful tool in keeping your app smooth and responsive by preventing any accidentally long-running code from blocking the browser from rendering. Web Workers are a simple means for apps to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface.\n\nA key architecture change you can make in your app is to manage application state in a worker and keep rendering updates to a minimum.\n\nBy moving your application state to a worker, you move complex business logic and data loading/processing there too.\n\nTo communicate with the user interface, data is sent between workers and the main UI thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler.\n\nCreating a store\n\nThe @ficusjs/state package provides a script named worker-app-state.iife.js specifically for creating stores in a web worker.\n\nIt is available at https://cdn.skypack.dev/@ficusjs/state@3/dist/worker-app-state.iife.js\n\nCreate a worker script worker.js for managing your application state.\n\n// import the app state creator function\nimportScripts('https://cdn.skypack.dev/@ficusjs/state@3/dist/worker-app-state.iife.js')\n\n// create the store\nconst store = globalThis.ficusjs.createAppState({\n  initialState: {\n    count: 0\n  },\n  increment (payload) {\n    this.setState(state => ({ count: payload }))\n  }\n})\n\n// this function communicates with the UI thread using postMessage\nfunction postState () {\n  globalThis.postMessage(Object.assign({}, store.state))\n}\n\n// subscribe to store changes\nstore.subscribe(postState)\n\n// listen for messages from the UI thread so actions can be triggered\nglobalThis.onmessage = function (e) {\n  const { actionName, payload } = e.data\n  store[actionName](payload)\n}\n\n// post the initial state to the UI thread\npostState()\n\nUsing the worker\n\nNow that you have a worker.js, the next step is to attach it to components in order to read state and dispatch actions.\n\nThe withWorkerStore function extends a component and hooks up the worker store to your components, providing local state and a dispatch method for invoking actions.\n\nFirstly, you'll need to export the worker for wiring up to components. This is important if you plan on sharing a single worker with multiple components.\n\nworker-store.js\n\nexport const worker = new Worker('./worker.js')\n\nNext, create one or more components using the withWorkerStore function.\n\ncomponent.js\n\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm'\nimport { createCustomElement, withWorkerStore } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// import the worker\nimport { worker } from './worker-store.js'\n\ncreateCustomElement('example-component',\n  withWorkerStore(worker, {\n    renderer,\n    increment () {\n      this.store.dispatch('increment', this.state.count + 1)\n    },\n    render () {\n      return html`Increment`\n    }\n  })\n)\n\nwithWorkerStore function\n\nThe withWorkerStore function extends a component and makes working with stores in web workers easier.\n\nThe withWorkerStore function provides a this.state property within the component as well as a this.store.dispatch() method for invoking store actions.\nIt also makes the component reactive to store changes as well as handling automatic store subscriptions based on the component lifecycle hooks.\nIt will also refresh computed getters when store state changes."},"browser-support.md":{"id":"browser-support.md","title":"Browser support","url":"/browser-support/","excerpt":"Browser support\n\nThe framework is for modern browsers - those supporting the ES2015+ Javascript...","body":"Browser support\n\nThe framework is for modern browsers - those supporting the ES2015+ Javascript language.\n\nhttps://caniuse.com/#feat=es6-module"},"computed-getters.md":{"id":"computed-getters.md","title":"Components - Computed getters","url":"/components/computed-getters/","excerpt":"Computed getters\n\nComputed getters are functions that are used like properties in your component. They are defined with the...","body":"Computed getters\n\nComputed getters are functions that are used like properties in your component. They are defined with the computed property.\n\nThey are memoized functions which means the result of the getter is cached for subsequent executions. This is useful when creating projections from large sets of data.\n\nSetting local state will automatically reset the computed cache.\n\nYou can access getters with this in your component render function.\n\ncomputed: {\n  myGetter () {\n    const name = 'Andy'\n    return `Hello, I'm ${name}`\n  }\n},\nrender () {\n  return html`${this.get.myGetter}`\n}"},"create-component.md":{"id":"create-component.md","title":"Components - createComponent function","url":"/components/create-component/","excerpt":"createComponent function\n\nThe createComponent function defines a new component containing internal reactive state with the...","body":"createComponent function\n\nThe createComponent function defines a new component containing internal reactive state with the provided tag plus declarative object and registers it in the browser as a custom element.\n\nInternally, the createComponent function uses the createCustomElement function and extends it with the withLocalState function.\n\nComponent names require a dash to be used in them; they cannot be single words - this is mandatory according to the custom element API.\n\nArguments\n\nWhen using the createComponent function, you must pass two arguments:\n\ntag name (for example my-component) - names require a dash to be used in them; they cannot be single words\nan object that defines the properties of the component\n\nThe following properties are used when creating components:\n\nProperty Required Type Description\nrenderer yes function A function that renders what is returned from the render function\nrender yes function A function that must return a response that can be passed to the renderer function for creating HTML\nroot  string Sets the root definition for the component\nprops  object Describes one or more property definitions - these are attributes and instance properties that can be set when using the component\ncomputed  object Contains one or more getters (functions that act like properties) that are useful when rendering\nstate  function Function that returns an object containing initial state. State is internal variables in the component\n*  function Functions that are useful in performing actions and logic\ncreated  function Invoked when the component is created and before it is connected to the DOM\nmounted  function Invoked when the component is first connected to the DOM. This may trigger before the components contents have been fully rendered\nupdated  function Invoked when the component is moved or reconnected to the DOM. This may trigger before the components contents have been fully rendered\nremoved  function Invoked each time the component is disconnected from the DOM\n\nState\n\nThe createComponent function provides reactive internal state using a Proxy.\n\nProvide the state property of your config object to set initial state. Every time a value of your state is updated, your component will re-render.\n\nYou can access state with this.state in your component render function.\n\nrender () {\n  return html`Hello, I'm ${this.state.name}`\n}\n\nInitial state function\n\nThe component's state option must be a function, so that each instance can maintain an independent copy of the returned state object.\nThis also allows you to use prop values as initial state.\n\nIf state is not a function, changing state in one instance would affect the state of all other instances.\n\n{\n  props: {\n    count: {\n      type: Number,\n      default: 0\n    }\n  },\n  state () {\n    return {\n      count: this.props.count\n    }\n  }\n}\n\nMutating state\n\nMutating state can be done using direct assignment or the setState method.\n\nDirect assignment\n\nMutating state values can be done using direct assignment.\n\nthis.state.name = 'new name value'\n\nsetState method\n\nThe setState method can be used to set one or more state values in a single transaction. This will only trigger a single render update. An optional callback can be provided which is invoked after rendering has occurred.\n\nThe setState function takes two arguments:\n\nState setter function (receives the current state as an argument)\nAn optional callback which is invoked after rendering\n\nthis.setState(\n  (state) => {\n    return {\n      // return new state property values\n    }\n  },\n  () => {\n    // do something after rendering\n  }\n)\n\nExample component using setState method\n\n// import the createComponent function\nimport { createComponent } from 'https://cdn.skypack.dev/ficusjs@6/component'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\ncreateComponent('set-state-example', {\n  renderer,\n  state () {\n    return {\n      count: 0,\n      isEven: false,\n      color: 'secondary'\n    }\n  },\n  increment () {\n    this.setState(\n      (state) => {\n        const count = state.count + 1\n        const isEven = count % 2 === 0\n        return {\n          count,\n          isEven,\n          color: isEven ? 'success' : 'info'\n        }\n      },\n      () => console.log('Component did render!')\n    )\n  },\n  render () {\n    return html`Count is&nbsp;${this.state.count}`\n  }\n})"},"create-custom-element.md":{"id":"create-custom-element.md","title":"Components - createCustomElement function","url":"/components/create-custom-element/","excerpt":"createCustomElement function\n\nThe createCustomElement function defines a new component with the provided tag plus declarative...","body":"createCustomElement function\n\nThe createCustomElement function defines a new component with the provided tag plus declarative object and registers it in the browser as a custom element.\n\nComponent names require a dash to be used in them; they cannot be single words - this is mandatory according to the custom element API.\n\nArguments\n\nWhen using the createCustomElement function, you must pass two arguments:\n\ntag name (for example my-component) - names require a dash to be used in them; they cannot be single words\nan object that defines the properties of the component\n\nThe following properties are used when creating components:\n\nProperty Required Type Description\nrenderer yes function A function that renders what is returned from the render function\nrender yes function A function that must return a response that can be passed to the renderer function for creating HTML\nroot  string Sets the root definition for the component\nprops  object Describes one or more property definitions - these are attributes and instance properties that can be set when using the component\ncomputed  object Contains one or more getters (functions that act like properties) that are useful when rendering\n*  function Functions that are useful in performing actions and logic\ncreated  function Invoked when the component is created and before it is connected to the DOM\nmounted  function Invoked when the component is first connected to the DOM. This may trigger before the components contents have been fully rendered\nupdated  function Invoked when the component is moved or reconnected to the DOM. This may trigger before the components contents have been fully rendered\nremoved  function Invoked each time the component is disconnected from the DOM\n\n// import the createCustomElement function\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\n// import the renderer and html tagged template literal from the htm renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm'\n\ncreateCustomElement('my-component', {\n  renderer,\n  props: {\n    personName: {\n      type: String,\n      required: true\n    }\n  },\n  render () {\n    return html`\n      \n        Hi, there! My name is ${this.props.personName}\n      \n    `\n  }\n})"},"emitting-events.md":{"id":"emitting-events.md","title":"Components - Emitting events","url":"/components/emitting-events/","excerpt":"Emitting events\n\nTo emit an event on the component, you can call the emit method anywhere in your component:\n\n// a component...","body":"Emitting events\n\nTo emit an event on the component, you can call the emit method anywhere in your component:\n\n// a component that emits an event (other properties omitted for brevity)\n{\n  emitChangeEvent () {\n    this.emit('change', { some: 'data' })\n  }\n}\n\n// a component that listens for an event\n{\n  handleEvent (e) {\n   console.log(e.detail) // prints { some: 'data' }\n  },\n  render () {\n    return html``\n  }\n}\n\nThe following arguments can be used to emit an event:\n\nProperty Required Description\neventName yes This must be a string with the name of the event\ndata  Optional data to pass along with the event. Any data passed is available on the Event.detail property of the event"},"lifecycle-hooks.md":{"id":"lifecycle-hooks.md","title":"Components - Lifecycle hooks","url":"/components/lifecycle-hooks/","excerpt":"Lifecycle hooks\n\nThere are several lifecycle hooks that you can provide when defining a component.\n\nThe automatic handling of...","body":"Lifecycle hooks\n\nThere are several lifecycle hooks that you can provide when defining a component.\n\nThe automatic handling of subscription/unsubscription happens when stores and event bus exists on a component. This prevents events or callbacks from triggering when a component disconnects and reconnects to the DOM.\n\ncreated function\n\nThe created hook will be invoked when the component has been created and before it is connected to the DOM.\n\n{\n  created () {\n    // do something when the component is created!\n  }\n}\n\nmounted function\n\nThe mounted hook will be invoked when the component has mounted in the DOM.\n\nThis may trigger before the components contents have been fully rendered.\n\nThis is triggered by the custom element connectedCallback lifecycle callback.\n\n{\n  mounted () {\n    // do something when the component is mounted!\n  }\n}\n\nupdated function\n\nThe updated hook will be invoked each time the component state changes.\n\nIt is also invoked when the component has been moved or is reconnected to the DOM.\nThis is triggered by the custom element connectedCallback lifecycle callback.\n\nThe component's DOM will have updated when this hook runs and may trigger before the components contents have been fully rendered.\n\n{\n  updated () {\n    // do something when the component is updated!\n  }\n}\n\nremoved function\n\nThe removed hook will be invoked each time the component has been disconnected from the document's DOM.\nThis is triggered by the custom element disconnectedCallback lifecycle callback.\n\n{\n  removed () {\n    // do something when the component is removed!\n  }\n}\n\npropsDidUpdate function\n\nThe propsDidUpdate hook will be invoked each time the component props are updated.\nThis is triggered by the custom element attributeChangedCallback lifecycle callback.\n\n{\n  propsDidUpdate () {\n    // do something when the component props are updated!\n  }\n}"},"methods.md":{"id":"methods.md","title":"Components - Methods","url":"/components/methods/","excerpt":"Methods\n\nIt is common to be able to call a method and perform an action. To achieve this, you can define methods when creating...","body":"Methods\n\nIt is common to be able to call a method and perform an action. To achieve this, you can define methods when creating your component.\nMethods are functions that can be defined anywhere in the component definition object.\n\ncreateCustomElement('example-component', {\n  renderer,\n  props: {\n    name: {\n      type: String\n    },\n    family: {\n      type: String\n    },\n    title: {\n      type: String\n    }\n  },\n  formatName (name, family, title) {\n    return `${title} ${name} ${family}`\n  },\n  render () {\n    return html`\n             \n               ${this.formatName(\n                 this.props.name,\n                 this.props.family,\n                 this.props.title\n               )}\n             \n           `\n  }\n})\n\nMethods are available anywhere in your component - inside getters or rendering. They are bound to the component instance."},"props.md":{"id":"props.md","title":"Components - Props","url":"/components/props/","excerpt":"Props\n\nYou pass props as HTML attributes on the component and then get access to them inside your component's JavaScript with...","body":"Props\n\nYou pass props as HTML attributes on the component and then get access to them inside your component's JavaScript with this.props. \n\nProps must be defined using camel-case but set as kebab-case in HTML. Values are converted between Javascript types and HTML attributes.\n\nProps are observed by default which means they react to changes and trigger re-renders.\n\n\n\nYou'll need to define your prop types in the component definition, like so:\n\nprops: {\n  className: {\n    type: String,\n    default: 'btn',\n    required: true, // is this required?\n    observed: false // turn off observing changes to this prop\n  },\n  required: {\n    type: Boolean,\n    default: false\n  }\n}\n\nThe following properties are used to define props:\n\nProperty Required Value\ntype yes This must be one of String, Number, Boolean or Object\ndefault  Set a default value if one is not set\nrequired  Is this prop required when the component is used? If so, set to true\nobserved  Set to false to turn off observing changes to this prop\n\nInstance properties\n\nProp values can be set on instances of components. Each prop you define for a component becomes an instance property and can be set using Javascript.\n\nconst exampleComponentInstance = document.querySelector('example-component')\nexampleComponentInstance.className = 'another-value'\n\nBuilt-in props\n\nFicusJS provides built-in props that are available on all components.\n\nProp name Type Description\nkey String A value often used to re-render a component\n\nProp types\n\nThere are a number of prop types available for use in components. These are defined in the type property of the prop definition.\n\nString\n\nprops: {\n  className: {\n    type: String\n  }\n}\n\nNumber\n\nprops: {\n  count: {\n    type: Number\n  }\n}\n\nBoolean\n\nprops: {\n  required: {\n    type: Boolean\n  }\n}\n\nObject\n\nprops: {\n  options: {\n    type: Object\n  }\n}\n\nArray\n\nprops: {\n  items: {\n    type: Array\n  }\n}\n\nFunction\n\nFunctions can be passed as props. These cannot be passed using HTML attributes as they cannot be converted from strings. Functions can only be passed using instance properties.\n\nprops: {\n  onClick: {\n    type: Function\n  }\n}"},"rendering.md":{"id":"rendering.md","title":"Components - Rendering","url":"/components/rendering/","excerpt":"Rendering\n\nBy default your render function must return a DOM element or HTML string for rendering. A built-in renderer function...","body":"Rendering\n\nBy default your render function must return a DOM element or HTML string for rendering. A built-in renderer function will convert strings to DOM elements automatically or render a given DOM element.\n\nExample using an HTML string\n\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\ncreateCustomElement('test-comp', {\n  props: {\n    personName: {\n      type: String\n    }\n  },\n  render () {\n    return `Hello ${this.props.personName}!`\n  }\n})\n\nExample using a DOM element\n\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\ncreateCustomElement('test-comp', {\n  props: {\n    personName: {\n      type: String\n    }\n  },\n  render () {\n    const element = document.createElement('p')\n    element.textContent = `Hello ${this.props.personName}!`\n    return element\n  }\n})\n\nCustom renderer\n\nA custom renderer function can be provided when creating a new component and is recommended. This allows any tagged template literal renderer to be plugged into a component.\n\nThere are a number of renderers available and can be added to suit your needs.\n\nWhen the render function is called, the result is passed to the renderer function for updating the DOM. This is handled within the component lifecycle.\n\nRenderer function\n\nThe renderer function can be any function that creates HTML from the result of the render function.\n\nThe renderer function will be invoked with the following arguments in order:\n\nArgument Description\nwhat The result returned from the render function\nwhere The DOM node to render into\n\nrenderer (what, where)\n\nIf your renderer function accepts a different argument order, simply pass a wrapper function to the component:\n\ncreateCustomElement('test-comp', {\n  renderer (what, where) {\n    // the uhtml renderer requires a different argument order\n    renderer(where, what)\n  }\n})\n\nRendering props\n\nProps can be rendered in the template.\n\n{\n  props: {\n    personName: {\n      type: String\n    }\n  },\n  render () {\n    return html`Hello ${this.props.personName}!`\n  }\n}\n\nRendering local state\n\nIf you have defined local state use this.state:\n\nrender () {\n  return html`${this.state.greeting}, there! My name is ${this.props.personName}`\n}\n\nAsync rendering\n\nYour render function is synchronous by default, but you can also defer rendering until some condition has been met by returning a Promise:\n\nrender () {\n  return new Promise(resolve => {\n    // check something here\n    resolve(html`My component with some content`)\n  })\n}\n\nForce a re-render\n\nThere are many cases where you will have a legitimate need to re-render a component.\n\nTo do this the proper way, every component has a default key prop. If the key stays the same, it won't change the component, but if the key changes, this triggers a re-render.\n\nThe key prop can be updated within the component using this.key = 'new-key' or by passing a new key prop to the component.\n\n{\n  updateKey (key) {\n    this.key = key\n  },\n  render () {\n    return html`\n      \n    `\n  }\n}"},"root-definition.md":{"id":"root-definition.md","title":"Components - Root definition","url":"/components/root-definition/","excerpt":"Root definition\n\nYou can use a standard root, a closed Shadow DOM root or an open Shadow DOM root by specifying a root in your...","body":"Root definition\n\nYou can use a standard root, a closed Shadow DOM root or an open Shadow DOM root by specifying a root in your config object:\n\nKey Value\nstandard A normal HTML root\nshadow An open Shadow DOM root\nshadow:closed A closed Shadow DOM root\n\n// import the createCustomElement function\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\n// import the renderer and html tagged template literal from the htm renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm'\n\ncreateCustomElement('my-component', {\n  renderer,\n  root: 'shadow',\n  props: {\n    personName: {\n      type: String,\n      required: true\n    }\n  },\n  mounted () {\n    console.log(this.shadowRoot.querySelector('p').textContent)\n  },\n  render () {\n    return html`\n      \n        Hi, there! My name is ${this.props.personName}\n      \n    `\n  }\n})"},"slots.md":{"id":"slots.md","title":"Components - Slots","url":"/components/slots/","excerpt":"Slots\n\nA slot is a placeholder inside your component for child elements.\nSlots will be created automatically depending on...","body":"Slots\n\nA slot is a placeholder inside your component for child elements.\nSlots will be created automatically depending on whether child elements exist. Child elements that do not specify a named slot are available using the default slot ${this.slots.default}.\n\nLet's say you have a `` component:\n\nhtml`\n\n  \n    \n    ${this.props.title}\n  \n  ${this.slots.default}\n\n`\n\nButtons can be passed as child elements:\n\n\n  Add\n  Save\n\n\nThis renders the buttons in the element `` inside the page header component.\n\nNamed slots\n\nNamed slots can also be created in your HTML templates. Let's modify the `` component:\n\nhtml`\n\n  ${this.slots.left}\n  ${this.slots.right}\n\n`\n\n\n  \n    \n    Expenses\n  \n  \n    Add\n    Save\n  \n\n\nThis renders the elements and into the elements and inside the page header component."},"create-event-bus.md":{"id":"create-event-bus.md","title":"Event bus - createEventBus function","url":"/event-bus/create-event-bus/","excerpt":"createEventBus function\n\nOnce you have created your events instance using createEventBus, simply pass it to each...","body":"createEventBus function\n\nOnce you have created your events instance using createEventBus, simply pass it to each component:\n\nimport { createCustomElement, createEventBus, withEventBus } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// create the event bus\nconst eventBus = createEventBus()\n\n// create a new component\ncreateCustomElement(\n  'my-component',\n  withEventBus(eventBus, {\n    /* pass component creation options here */\n  })\n)"},"get-event-bus.md":{"id":"get-event-bus.md","title":"Event bus - getEventBus function","url":"/event-bus/get-event-bus/","excerpt":"getEventBus function\n\nThe getEventBus function is a quick way to retrieve the events instance.\nIf the event bus has not yet been...","body":"getEventBus function\n\nThe getEventBus function is a quick way to retrieve the events instance.\nIf the event bus has not yet been created, getEventBus will create a new instance automatically.\n\n// import the function\nimport { createCustomElement, getEventBus, withEventBus } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// use it within a component\ncreateCustomElement(\n  'my-component',\n  withEventBus(getEventBus(), {\n    /* pass component creation options here */\n  })\n)"},"publish.md":{"id":"publish.md","title":"Event bus - Publish","url":"/event-bus/publish/","excerpt":"Publish\n\nWhen you want to notify subscribers, you need to publish to a topic:\n\neventBus.publish('myTopic', data)\n\nThe following...","body":"Publish\n\nWhen you want to notify subscribers, you need to publish to a topic:\n\neventBus.publish('myTopic', data)\n\nThe following arguments are passed when publishing to a topic:\n\nProperty Required Description\ntopic yes The name of the topic\ndata  Optional data to pass along to subscribers\n\nSubscribers\n\nWhen publishing to a topic, the return value is a Map of subscribers notified with the message.\n\nThe Map contains the callback and an object with the subscriber options.\n\nThe subscriber options contain the callCount of how many times the subscriber has been notified.\n\nconst notified = eventBus.publish('myTopic', data)\n\nnotified.forEach((callback, options) => {\n  // how many times this subscriber has been called\n  console.log(options.callCount)\n})"},"subscribers.md":{"id":"subscribers.md","title":"Event bus - Subscribers","url":"/event-bus/subscribers/","excerpt":"Subscribers\n\nTo retrieve the subscribers for a topic, use the getSubscribers method.\nThis method returns a Map of subscribers...","body":"Subscribers\n\nTo retrieve the subscribers for a topic, use the getSubscribers method.\nThis method returns a Map of subscribers for a topic or object of all subscribers for all topics.\n\nconst subscribers = eventBus.getSubscribers('myTopic')\n\nThe Map contains the callback and an object with the subscriber options.\n\nThe subscriber options contain the callCount of how many times the subscriber has been notified.\n\nsubscribers.forEach((callback, options) => {\n  // how many times this subscriber has been called\n  console.log(options.callCount)\n})"},"extension-builder.md":{"id":"extension-builder.md","title":"Extending components - Extension builder","url":"/extending-components/extension-builder/","excerpt":"Extension builder\n\nWorking with multiple component extensions can be made easier by using the ExtensionBuilder class.\n\n// import...","body":"Extension builder\n\nWorking with multiple component extensions can be made easier by using the ExtensionBuilder class.\n\n// import it with all other features\nimport { createCustomElement, ExtensionBuilder } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// Alternatively, import the ExtensionBuilder function\n// import { ExtensionBuilder } from 'https://cdn.skypack.dev/ficusjs@6/extension-builder'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\nimport { store } from './store.mjs'\nimport { i18n } from './i18n.mjs'\n\ncreateCustomElement(\n  'example-button',\n  ExtensionBuilder\n    .newInstance()\n    .withStore(store)\n    .withI18n(i18n)\n    .create({\n      clear () {\n        this.store.clear()\n      },\n      render () {\n        return html`${this.i18n.t('buttons.clear')}`\n      }\n    })\n)\n\nThe ExtensionBuilder class uses the builder pattern to make it easier to use more than one component extension.\n\nMethods\n\nThe methods of the ExtensionBuilder can be chained.\n\nnewInstance()\n\nCreate a new instance of the ExtensionBuilder class.\n\nconst builder = ExtensionBuilder.newInstance()\n\nwithBreakpointRender(breakpointConfig)\n\nUse the withBreakpointRender extension function.\n\nconst breakpointConfig = {\n  reactive: false,\n  breakpoints: {\n    992: { method: 'renderTablet' },\n    768: { method: 'renderMobile' },\n    1200: { method: 'renderDesktop' }\n  }\n}\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withBreakpointRender(breakpointConfig)\n\nwithEventBus(eventBus)\n\nUse the withEventBus extension function.\n\nimport { eventBus } from './event-bus.mjs'\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withEventBus(eventBus)\n\nwithI18n(i18n)\n\nUse the withI18n extension function.\n\nimport { i18n } from './i18n.mjs'\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withI18n(i18n)\n\nwithI18nReactive(i18n)\n\nUse the withI18nReactive extension function.\n\nimport { i18n } from './i18n.mjs'\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withI18nReactive(i18n)\n\nwithLazyRender()\n\nUse the withLazyRender extension function.\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withLazyRender()\n\nwithStyles()\n\nUse the withStyles extension function.\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withStyles()\n\nwithLocalState()\n\nUse the withLocalState extension function.\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withLocalState()\n\nwithStore(store)\n\nUse the withStore extension function.\n\nimport { store } from './store.mjs'\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withStore(store)\n\nwithWorkerStore(worker)\n\nUse the withWorkerStore extension function.\n\nimport { worker } from './worker-store.mjs'\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withWorkerStore(worker)\n\nwithXStateService(service)\n\nUse the withXStateService extension function.\n\nimport { getXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst service = getXStateService('toggle.service')\n\nconst builder = ExtensionBuilder\n  .newInstance()\n  .withXStateService(service)\n\ncreate(options)\n\nCreate component options with added extensions. This method wraps all extensions with supplied component options.\n\ncreateCustomElement(\n  'example-button',\n  ExtensionBuilder\n    .newInstance()\n    .withStore(store)\n    .withI18n(i18n)\n    .create({\n      clear () {\n        this.store.clear()\n      },\n      render () {\n        return html`${this.i18n.t('buttons.clear')}`\n      }\n    })\n)"},"with-breakpoint-render.md":{"id":"with-breakpoint-render.md","title":"Extending components - withBreakpointRender function","url":"/extending-components/with-breakpoint-render/","excerpt":"withBreakpointRender function\n\nThe withBreakpointRender function extends a component with conditional rendering based on...","body":"withBreakpointRender function\n\nThe withBreakpointRender function extends a component with conditional rendering based on viewport breakpoints.\n\nIt uses window.matchMedia to set a render function based on breakpoints. By testing the viewport size, it can conditionally render a specific set of HTML.\n\nThe withBreakpointRender function will test the viewport size and set a specific render function when the component is mounted.\n\nOptionally, breakpoints can be reactive which means the component will re-render automatically based on viewport resizing.\n\n// import it with all other features\nimport { createCustomElement, withBreakpointRender } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withBreakpointRender } from 'https://cdn.skypack.dev/ficusjs@6/with-breakpoint-render'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// define a breakpoint configuration\nconst breakpointConfig = {\n  reactive: false,\n  breakpoints: {\n    992: { method: 'renderTablet' },\n    768: { method: 'renderMobile' },\n    1200: { method: 'renderDesktop' }\n  }\n}\n\n// create the component\ncreateCustomElement(\n  'breakpoint-component',\n  withBreakpointRender(breakpointConfig, {\n    renderer,\n    renderTablet () {\n      return html`Breakpoint render tablet`\n    },\n    renderMobile () {\n      return html`Breakpoint render mobile`\n    },\n    renderDesktop () {\n      return html`Breakpoint render desktop`\n    }\n  })\n)\n\nBreakpoint config\n\nThe withBreakpointRender requires a breakpoint config. This sets the viewport widths along with the render functions to use for that breakpoint.\n\nconst breakpointConfig = {\n  reactive: false,\n  breakpoints: {\n    992: { method: 'renderTablet' },\n    768: { method: 'renderMobile' },\n    1200: { method: 'renderDesktop' }\n  }\n}\n\nThe reactive property will make the component automatically re-render when the viewport width changes.\n\nEach breakpoint has a width key and an object containing a method to use at that viewport breakpoint.\n\nThe above config results in the following media query list.\n\nonly screen and (max-width: 768px)\nonly screen and (min-width: 769px) and (max-width: 992px)\nonly screen and (min-width: 1201px)"},"with-event-bus.md":{"id":"with-event-bus.md","title":"Extending components - withEventBus function","url":"/extending-components/with-event-bus/","excerpt":"withEventBus function\n\nThe withEventBus function extends a component and makes working with an event bus easier in component...","body":"withEventBus function\n\nThe withEventBus function extends a component and makes working with an event bus easier in component methods.\n\n// import it with all other features\nimport { createCustomElement, withEventBus } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withEventBus } from 'https://cdn.skypack.dev/ficusjs@6/with-event-bus'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import an event bus from a local file\nimport { eventBus } from './event-bus.js'\n\ncreateCustomElement(\n  'my-component',\n  withEventBus(eventBus, {\n    renderer,\n    buttonClicked () {\n      this.eventBus.publish('increment', undefined)\n    },\n    render () {\n      return html`Increment`\n    }\n  })\n)\n\nThe withEventBus function provides a this.eventBus property within the component.\nIt handles automatic event bus subscription based on the component lifecycle hooks.\n\nsetEventBus method\n\nThe setEventBus method can be called when an instance needs to be set after the component has initialised.\nThe method accepts an eventBus argument which is a single event instance.\n\n{\n  someMethod () {\n    const eventBus = getEventBus()\n    this.setEventBus(eventBus)\n  }\n}"},"with-i18n-reactive.md":{"id":"with-i18n-reactive.md","title":"Extending components - withI18nReactive function","url":"/extending-components/with-i18n-reactive/","excerpt":"withI18nReactive function\n\nThe withI18nReactive function extends a component and makes working with internationalization (i18n)...","body":"withI18nReactive function\n\nThe withI18nReactive function extends a component and makes working with internationalization (i18n) easier in components.\n\nThe function works with the event bus to listen for locale changes.\nIf the event bus is available on the component instance, the topic i18n:locale:changed is automatically subscribed to and will trigger the component re-render.\nThis is useful when the component is used in a multi-locale application and you want to re-render the component when the locale changes.\n\n// import it with all other features\nimport { createCustomElement, withI18nReactive, withEventBus } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the functions directly\n// import { withI18nReactive } from 'https://cdn.skypack.dev/ficusjs@6/with-i18n-reactive'\n// import { withEventBus } from 'https://cdn.skypack.dev/ficusjs@6/with-event-bus'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import an I18n instance from a local file\nimport { i18n } from './i18n.js'\n\n// import an event bus instance\nimport { eventBus } from './event-bus.js'\n\ncreateCustomElement(\n  'my-component',\n  withEventBus(eventBus,\n    withI18nReactive(i18n, {\n      renderer,\n      buttonClicked () {\n        // handle event\n      },\n      render () {\n        return html`${this.i18n.t('buttons.increment')}`\n      }\n    })\n  )\n)\n\nThe withI18nReactive function provides a this.i18n property within the component.\nThe following methods are available within the component on this..i18n.\n\nt(key, templateData, options)\n\nThe t() method retrieves the translation message for the current locale.\nThe following arguments can be passed to the t() method.\n\nArgument Type Required Description\nkey string Yes The key for the specific message. This can be a nested key like buttons.increment\ntemplateData object  The optional data for message interpolation. The keys must match the message value. For example; the message Greeting {{ name }} requires a templateData object containing { name: 'FicuJS' }\noptions object  An optional set of options for the message translation\n\ngetLocale()\n\nThe getLocale() method gets the current locale of the i18n instance.\n\nsetLocale(locale)\n\nThe setLocale() method sets the current locale of the i18n instance.\n\nThe following arguments can be passed to the setLocale() method.\n\nArgument Type Required Description\nlocale string Yes The locale string. The default is en\n\nsetI18n method\n\nThe setI18n() method can be called when an instance needs to be set after the component has initialised.\nThe method accepts an i18n argument which is a single I18n instance.\n\n{\n  someMethod () {\n    const i18n = getI18n()\n    this.setI18n(i18n)\n  }\n}"},"with-i18n.md":{"id":"with-i18n.md","title":"Extending components - withI18n function","url":"/extending-components/with-i18n/","excerpt":"withI18n function\n\nThe withI18n function extends a component and makes working with internationalization (i18n) easier in...","body":"withI18n function\n\nThe withI18n function extends a component and makes working with internationalization (i18n) easier in components.\n\n// import it with all other features\nimport { createCustomElement, withI18n } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withI18n } from 'https://cdn.skypack.dev/ficusjs@6/with-i18n'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import an I18n instance from a local file\nimport { i18n } from './i18n.js'\n\ncreateCustomElement(\n  'my-component',\n  withI18n(i18n, {\n    renderer,\n    buttonClicked () {\n      // handle event\n    },\n    render () {\n      return html`${this.i18n.t('buttons.increment')}`\n    }\n  })\n)\n\nThe withI18n function provides a this.i18n property within the component.\nThe following methods are available within the component on this..i18n.\n\nt(key, templateData, options)\n\nThe t() method retrieves the translation message for the current locale.\nThe following arguments can be passed to the t() method.\n\nArgument Type Required Description\nkey string Yes The key for the specific message. This can be a nested key like buttons.increment\ntemplateData object  The optional data for message interpolation. The keys must match the message value. For example; the message Greeting {{ name }} requires a templateData object containing { name: 'FicuJS' }\noptions object  An optional set of options for the message translation\n\ngetLocale()\n\nThe getLocale() method gets the current locale of the i18n instance.\n\nsetLocale(locale)\n\nThe setLocale() method sets the current locale of the i18n instance.\n\nThe following arguments can be passed to the setLocale() method.\n\nArgument Type Required Description\nlocale string Yes The locale string. The default is en\n\nsetI18n method\n\nThe setI18n() method can be called when an instance needs to be set after the component has initialised.\nThe method accepts an i18n argument which is a single I18n instance.\n\n{\n  someMethod () {\n    const i18n = getI18n()\n    this.setI18n(i18n)\n  }\n}"},"with-lazy-render.md":{"id":"with-lazy-render.md","title":"Extending components - withLazyRender function","url":"/extending-components/with-lazy-render/","excerpt":"withLazyRender function\n\nThe withLazyRender function extends a component with conditional/lazy rendering.\n\nIt creates an...","body":"withLazyRender function\n\nThe withLazyRender function extends a component with conditional/lazy rendering.\n\nIt creates an IntersectionObserver instance internally to track when the component is visible. By knowing when the component is visible, it can conditionally/lazily render the component for optimum performance.\n\nThe withLazyRender function provides an elementVisible property for checking the visibility of the component.\n\nWhen the component becomes visible, it triggers a render which then calls the component lifecycle methods.\n\n// import it with all other features\nimport { createCustomElement, withLazyRender } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withLazyRender } from 'https://cdn.skypack.dev/ficusjs@6/with-lazy-render'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// as there is no initial content rendered, the `mounted` method\n// is triggered when the component is visible\ncreateCustomElement(\n  'lazy-component',\n  withLazyRender({\n    renderer,\n    render () {\n      return this.elementVisible\n        ? html`A styled button`\n        : ''\n    },\n    mounted () {\n      // when elementVisible changes this will be called so we can load extra stuff we need\n    }\n  })\n)\n\n// as there is initial rendered content, the `updated` method\n// is triggered when the component is visible\ncreateCustomElement(\n  'lazy-component-with-placeholder',\n  withLazyRender({\n    renderer,\n    render () {\n      return this.elementVisible\n        ? html`A styled button`\n        : ''\n    },\n    updated () {\n      // when elementVisible changes this will be called so we can load extra stuff we need\n    }\n  })\n)"},"with-local-state.md":{"id":"with-local-state.md","title":"Extending components - withLocalState function","url":"/extending-components/with-local-state/","excerpt":"withLocalState function\n\nThe withLocalState function extends a component and makes working with local state easier.\n\nWhen using...","body":"withLocalState function\n\nThe withLocalState function extends a component and makes working with local state easier.\n\nWhen using the withLocalState function, the state property of your config object must set initial state.\nThis makes the component reactive to state changes. Every time a value of your state is updated, your component will re-render.\n\n// import the createCustomElement function\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\n// import the withLocalState function\nimport { withLocalState } from 'https://cdn.skypack.dev/ficusjs@6/with-local-state'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\ncreateCustomElement(\n  'with-state-example',\n  withLocalState({\n    renderer,\n    state () {\n      return {\n        count: 0,\n        isEven: false,\n        color: 'secondary'\n      }\n    },\n    increment () {\n      this.setState(\n        (state) => {\n          const count = state.count + 1\n          const isEven = count % 2 === 0\n          return {\n            count,\n            isEven,\n            color: isEven ? 'success' : 'info'\n          }\n        },\n        () => console.log('Component did render!')\n      )\n    },\n    render () {\n      return html`Count is&nbsp;${this.state.count}`\n    }\n  })\n)\n\nYou can access state with this.state in your component render function.\n\nrender () {\n  return html`Hello, I'm ${this.state.name}`\n}\n\nInitial state function\n\nThe component's state option must be a function, so that each instance can maintain an independent copy of the returned state object.\nThis also allows you to use prop values as initial state.\n\nIf state is not a function, changing state in one instance would affect the state of all other instances.\n\n{\n  props: {\n    count: {\n      type: Number,\n      default: 0\n    }\n  },\n  state () {\n    return {\n      count: this.props.count\n    }\n  }\n}\n\nMutating state\n\nMutating state can be done using direct assignment or the setState method.\n\nDirect assignment\n\nMutating state values can be done using direct assignment.\n\nthis.state.name = 'new name value'\n\nsetState method\n\nThe setState method can be used to set one or more state values in a single transaction. This will only trigger a single render update. An optional callback can be provided which is invoked after rendering has occurred.\n\nThe setState function takes two arguments:\n\nState setter function (receives the current state as an argument)\nAn optional callback which is invoked after rendering\n\nthis.setState(\n  (state) => {\n    return {\n      // return new state property values\n    }\n  },\n  () => {\n    // do something after rendering\n  }\n)"},"with-state-transactions.md":{"id":"with-state-transactions.md","title":"Extending components - withStateTransactions function","url":"/extending-components/with-state-transactions/","excerpt":"withStateTransactions function Deprecated\n\nThe withStateTransactions is deprecated. Please use the component setState method for...","body":"withStateTransactions function Deprecated\n\nThe withStateTransactions is deprecated. Please use the component setState method for mutating state within a transaction.\n\n\nThe withStateTransactions function extends a component with transactions so multiple state changes can occur without triggering a re-render.\n\n// import it with all other features\nimport { createComponent, withStateTransactions } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withStateTransactions } from 'https://cdn.skypack.dev/ficusjs@6/with-state-transactions'\n\n// import the renderer and html tagged template literal from the lit-html library\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/lit-html'\n\ncreateComponent(\n  'my-like-component',\n  withStateTransactions({\n    renderer,\n    state () {\n      return { count: 0, message: null, status: 'unliked' }\n    },\n    like () {\n      // start a transaction\n      this.beginTransaction()\n\n      // change some state\n      this.state.count = this.state.count + 1\n      this.state.message = 'Thanks for liking this!'\n\n      // save the like to the server\n      window.fetch('/api/likes', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ count: this.state.count, updatedBy: 'Jane Doe' })\n      })\n      .then(res => res.json())\n      .then(data => {\n        this.state.status = 'liked'\n        this.endTransaction()\n      })\n      .catch(err => {\n        this.rollbackTransaction()\n        this.state.status = 'error'\n      })\n    },\n    render () {\n      if (this.state.status === 'liked') {\n         return html`${this.state.message}`\n      }\n      return html`Like`\n    }\n  })\n)\n\nA transaction is a sequence of operations performed on state as a single logical unit of work.\nThe transaction can be either all committed (applied to state) or all rolled back (undone from state).\n\nbeginTransaction method Deprecated\n\nThe beginTransaction method starts a transaction.\n\nendTransaction method Deprecated\n\nThe endTransaction method ends the transaction and triggers a component render.\n\nrollbackTransaction method Deprecated\n\nThe rollbackTransaction method rolls back the state changes carried out within the transaction.\nThis is used if an error occurs, and the state needs to be reset."},"with-store.md":{"id":"with-store.md","title":"Extending components - withStore function","url":"/extending-components/with-store/","excerpt":"withStore function\n\nThe withStore function extends a component and makes working with stores easier in component rendering,...","body":"withStore function\n\nThe withStore function extends a component and makes working with stores easier in component rendering, computed getters and methods.\n\n// import it with all other features\nimport { createCustomElement, withStore } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withStore } from 'https://cdn.skypack.dev/ficusjs@6/with-store'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import a single store or object of stores from a local file\nimport { store } from './store.js'\n\ncreateCustomElement(\n  'my-component',\n  withStore(store, {\n    renderer,\n    props: {\n      personName: {\n        type: String,\n        required: true\n      }\n    },\n    render () {\n      return html`\n        \n          ${this.store.state.greeting}, there! My name is ${this.props.personName}\n        \n      `\n    }\n  })\n)\n\nThe withStore function provides a this.store property within the component.\nIt also makes the component reactive to store changes as well as handling automatic store subscriptions based on the component lifecycle hooks.\nIt will also refresh computed getters when store state changes.\n\nsetStore method\n\nThe setStore method can be called when a store instance needs to be set after the component has initialised.\nThe method accepts a store argument which can be a single store instance or object of store instances.\n\n{\n  someMethod () {\n    const store = getStoreSomehow()\n    this.setStore(store)\n  }\n}"},"with-styles.md":{"id":"with-styles.md","title":"Extending components - withStyles function","url":"/extending-components/with-styles/","excerpt":"withStyles function\n\nThe withStyles function extends a component and makes working with component styles more efficient\nby...","body":"withStyles function\n\nThe withStyles function extends a component and makes working with component styles more efficient\nby providing a styles function which is invoked injecting CSS into the `` once for all component instances.\n\n// import it with all other features\nimport { createCustomElement, withStyles } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// alternatively, import the function directly\n// import { withStyles } from 'https://cdn.skypack.dev/ficusjs@6/with-styles'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import the css tagged template literal\nimport { css } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/css'\n\ncreateCustomElement(\n  'my-component',\n  withStyles({\n    renderer,\n    styles () {\n      return css`\n        my-component button {\n          background-color: yellow;\n          color: black;\n        }\n      `\n    },\n    render () {\n      return html`A styled button`\n    }\n  })\n)\n\nThe withStyles function automatically handles loading styles based on the component lifecycle hooks.\n\nstyles function\n\nThe styles function must be provided when using the withStyles function. This function is invoked and injects CSS into the ``\nonce for all component instances.\n\nThe styles function can return:\n\na CSS String\nURL to an external stylesheet\na css tagged template literal\nstyle element\nArray containing any combination of the above!\n\nCSS string styles\n\nReturn a string containing styles.\n\n{\n  styles () {\n    return `\n      my-component button {\n        background-color: yellow;\n        color: black;\n      }\n    `\n  }\n}\n\nExternal stylesheet\n\nReturn a URL to a stylesheet - must be a fully qualified URL, not a relative path.\n\nExternal stylesheets are injected into the head as link[rel=stylesheet] tags.\n\n{\n  styles () {\n    return 'https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css'\n  }\n}\n\ncss tagged template literal\n\nReturn a css tagged template literal.\n\n{\n  styles () {\n    return css`\n      my-component button {\n        background-color: yellow;\n        color: black;\n      }\n    `\n  }\n}\n\nstyle element\n\nReturn a style element.\n\n{\n  styles () {\n    const cssText = `\n      my-component button {\n        background-color: yellow;\n        color: black;\n      }\n    `\n    const style = document.createElement('style')\n    style.appendChild(document.createTextNode(cssText))\n    return style\n  }\n}\n\nMixed\n\nReturn a mixed array containing multiple combinations of styles.\n\n{\n  styles () {\n    return [\n      'https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css',\n      `\n        my-component button {\n          background-color: yellow;\n          color: black;\n        }\n      `,\n      css`\n        my-other-component button {\n          background-color: yellow;\n          color: black;\n        }\n      `\n    ]\n  }\n}"},"with-worker-store.md":{"id":"with-worker-store.md","title":"Extending components - withWorkerStore function","url":"/extending-components/with-worker-store/","excerpt":"withWorkerStore function\n\nThe withWorkerStore function extends a component and makes working with stores in web workers...","body":"withWorkerStore function\n\nThe withWorkerStore function extends a component and makes working with stores in web workers easier.\n\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm'\nimport { createCustomElement, withWorkerStore } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// import the worker\nimport { worker } from './worker-store.js'\n\ncreateCustomElement('example-component',\n  withWorkerStore(worker, {\n    renderer,\n    increment () {\n      this.store.dispatch('increment', this.state.count + 1)\n    },\n    render () {\n      return html`Increment`\n    }\n  })\n)\n\nThe withWorkerStore function provides a this.state property within the component as well as a this.store.dispatch() method for invoking store actions.\nIt also makes the component reactive to store changes as well as handling automatic store subscriptions based on the component lifecycle hooks.\nIt will also refresh computed getters when store state changes.\n\ndispatch method\n\nThe dispatch method can be called to invoke an action in the store.\n\nthis.store.dispatch('increment', this.state.count + 1)\n\nThe dispatch method takes two parameters:\n\nactionKey is the string name of your action\npayload is the data that you want to pass along to your action"},"features.md":{"id":"features.md","title":"Script loader - Features","url":"/script-loader/features/","excerpt":"Features\n\nLazy load ES modules\nLazy load ES5 scripts\nDynamically load based on path\nFunctional programming patterns\nSmall...","body":"Features\n\nLazy load ES modules\nLazy load ES5 scripts\nDynamically load based on path\nFunctional programming patterns\nSmall footprint (1.3 KB gzipped for everything!)\nNo dependencies\nWorks with client-side frameworks"},"create-ficus-app.md":{"id":"create-ficus-app.md","title":"Create Ficus App","url":"/getting-started/create-ficus-app/","excerpt":"Create Ficus App\n\nSet-up a web app with FicusJS quickly and easily.\n\nGetting started\n\nWhen you want to get started with FicusJS...","body":"Create Ficus App\n\nSet-up a web app with FicusJS quickly and easily.\n\nGetting started\n\nWhen you want to get started with FicusJS and web components, Create Ficus App lets you focus on code, not build tools.\n\nTo create a project called my-app, run this command:\n\nnpx create-ficus-app my-app\n\nThis will create a project using the Snowpack app starter project.\n\nStarter projects\n\nDepending on what you need to build, Create Ficus App offers a selection of starter projects.\n\nMore to follow soon!\n\nRocket app - a simple app using Rocket\nVite app - a simple app using Vite\nSnowpack app - a simple app using Snowpack\nBasic app - a simple, single HTML page with inline scripts\n11ty app - a Jamstack site based on 11ty\n\nTo choose a starter project, run this command:\n\nnpx create-ficus-app"},"editor.md":{"id":"editor.md","title":"Editor set-up","url":"/getting-started/editor/","excerpt":"Editor set-up\n\nFicusJS works well with most editors.\n\nVSCode extensions\n\nYou can install the following extensions in VSCode to...","body":"Editor set-up\n\nFicusJS works well with most editors.\n\nVSCode extensions\n\nYou can install the following extensions in VSCode to get the best possible editing experience.\n\nlit-html - Syntax highlighting and IntelliSense for html inside of JavaScript and TypeScript tagged template strings\nStandardJS - Integrates JavaScript Standard Style into VS Code.\nStyled components - Syntax highlighting for styled-components\nXState VSCode - Visual editing, autocomplete and typegen for XState"},"examples.md":{"id":"examples.md","title":"Codepen examples","url":"/getting-started/examples/","excerpt":"Codepen Examples\n\nYou can find a set of FicusJS examples on Codepen at...","body":"Codepen Examples\n\nYou can find a set of FicusJS examples on Codepen at https://codepen.io/collection/nRvEaw"},"installation.md":{"id":"installation.md","title":"Script loader - Installation","url":"/script-loader/installation/","excerpt":"Installation\n\nFicusJS script loader can be installed in a number of ways.\n\nCDN\n\nWe recommend using native ES modules in the...","body":"Installation\n\nFicusJS script loader can be installed in a number of ways.\n\nCDN\n\nWe recommend using native ES modules in the browser.\n\n\n  import { loadScript } from 'https://cdn.skypack.dev/@ficusjs/script@2'\n\n\nFicusJS script loader is available on Skypack.\n\nNPM\n\nFicusJS script loader works nicely with build tools such as Webpack or Rollup. If you are using a NodeJS tool, you can install the NPM package.\n\nnpm install @ficusjs/script\n\nAvailable builds\n\nFicusJS script loader is only available as an ES module. For legacy browsers or alternative modules such as CommonJS, it is recommended to use a build tool to transpile the code.\n\nThe following builds are available.\n\nScript dist/script.js"},"going-build-less.md":{"id":"going-build-less.md","title":"Going build-less","url":"/going-build-less/","excerpt":"Going build-less\n\nBrowsers have improved a lot over the past years. It's now possible to do web development without requiring...","body":"Going build-less\n\nBrowsers have improved a lot over the past years. It's now possible to do web development without requiring any build tools, using the native module loader of the browser. We think this is a great fit for FicusJS, and we recommend this as a general starting point.\n\nBuild tools can quickly add a lot of complexity to your code, and make your code reliant on a specific build setup. We think it's best to avoid them during development, or only add them for light transformations if you know what you're doing.\n\nRead this article to learn more about this approach.\n\nIf your project is using an existing build tool, FicusJS is fully compatible and can work alongside other libraries and frameworks."},"create-i18n.md":{"id":"create-i18n.md","title":"I18n - createI18n function","url":"/i18n/create-i18n/","excerpt":"createI18n function\n\nCreating a new i18n instance using createI18n will create an instance of the I18n class.\nThis class...","body":"createI18n function\n\nCreating a new i18n instance using createI18n will create an instance of the I18n class.\nThis class provides methods for working with multiple languages and localisations.\n\nThe i18n instance will be created as a singleton - this ensures only one instance exists.\n\nimport { createI18n } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// create the i18n instance and add the messages\nconst i18n = createI18n()\n\nThe current locale is set according to the following rules:\n\nlang query string parameter ?lang=es\nHTML lang attribute ``\nnavigator.language property\n\nMethods\n\nThe following methods are available on the i18n instance.\n\nadd(items, locale, prefix)\n\ni18n.add({ greeting: 'Hello FicusJS' }, 'en')\n\nThe add() method adds messages to the i18n instance.\n\nMessage interpolation uses double handlebars {{ value }}.\n\nThe following arguments can be passed to the add() method.\n\nArgument Type Required Description\nitems object Yes The object containing messages\nlocale string  An optional locale for the messages. For example es. The default is en\nprefix string  An optional prefix for the messages\n\nPluralization is set by adding an array of messages to the items object.\n\ni18n.add({\n  greeting: 'Hello FicusJS'\n  itemsCaption: [\n    '1 item',\n    '0 or more items'\n  ]\n})\n\nInterpolation is also supported in pluralization messages.\n\nt(key, templateData, options)\n\nThe t() method retrieves the translation message for the current locale.\n\nTranslation messages are stored under the specified key according to the current locale.\nIf templateData is present, messages are interpolated with templateData.\n\nA specific locale translation can be specified via options.locale.\n\nPluralization\n\nPluralization is calculated by examining the count property passed in the templateData object.\n\ni18n.t('itemsCaption', { count: 0 }) // outputs  \"0 or more items\"\ni18n.t('itemsCaption', { count: 1 }) // outputs  \"1 item\"\ni18n.t('itemsCaption', { count: 2 }) // outputs  \"0 or more items\"\n\nThe count property can be changed in the options object by specifying pluralizeTo.\n\ni18n.t('itemsCaption', { num: 0 }, { pluralizeTo: 'num' }) // outputs  \"0 items\"\ni18n.t('itemsCaption', { num: 1 }, { pluralizeTo: 'num' }) // outputs  \"1 item\"\ni18n.t('itemsCaption', { num: 2 }, { pluralizeTo: 'num' }) // outputs  \"2 items\"\n\nArguments\n\nThe following arguments can be passed to the t() method.\n\nArgument Type Required Description\nkey string Yes The key for the specific message. This can be a nested key like navbar.buttons.home\ntemplateData object  The optional data for message interpolation. The keys must match the message value. For example; the message Greeting {{ name }} requires a templateData object containing { name: 'FicusJS' }\noptions object  An optional set of options for the message translation\n\nThe following options can be passed to the options object.\n\nOption Type Required Description\nlocale string  An optional locale for the messages. For example es. The default is en\npluralizeTo string  An optional property name to use for pluralization. The default is count\n\ni18n.t('greeting', { name: 'FicusJS' }, { locale: 'es' })\n\nsetLocale(locale)\n\nThe setLocale() method sets the current locale of the i18n instance.\n\nThe following arguments can be passed to the setLocale() method.\n\nArgument Type Required Description\nlocale string Yes The locale string. The default is en\n\ni18n.setLocale('es')\n\ngetLocale()\n\nThe getLocale() method gets the current locale of the i18n instance.\n\nconst locale = i18n.getLocale()\n\n// locale is 'es'\n\ninterpolateWith(userRE)\n\nThe interpolateWith() method sets the regular expression for template strings interpolation.\nBy default, string interpolation uses double handlebars {{ value }}.\n\nThis can be overridden using the interpolateWith() with the following arguments.\n\nArgument Type Required Description\nuserRE RegExp Yes The regex for template string interpolation\n\ni18n.add({ welcomeMessage: 'Hello $userName' })\n\ni18n.interpolateWith(/\\$(\\w+)/g)\n\nconst value = i18n.t('welcomeMessage', { userName: 'George' })\n\n// value is 'Hello George'\n\nsetPluralizationRule(locale, rule, options)\n\nThe setPluralizationRule() method sets a locale-specific pluralization rule function to determine plural form variation index.\n\ni18n.setPluralizationRule('en', function (count) {\n    return (1 === count) ? 0 : 1\n}, { pluralizeTo: 'count' })\n\nwhenUndefined(key, locale)\n\nThe whenUndefined() method defines a custom handler for when the requested item is not available.\n\ni18n.whenUndefined = function (key, locale) {\n    return `${key}:undefined:${locale}`\n}\n\nconst value = i18n.t('errors.dateInput')\n\n// value is 'errors.dateInput:undefined:es'\n\nclear()\n\nThe clear() method empties the instance of messages.\n\ni18n.clear()"},"get-i18n.md":{"id":"get-i18n.md","title":"I18n - getI18n function","url":"/i18n/get-i18n/","excerpt":"getI18n function\n\nThe getI18n function is a quick way to retrieve the i18n instance.\nIf the i18n instance has not yet been...","body":"getI18n function\n\nThe getI18n function is a quick way to retrieve the i18n instance.\nIf the i18n instance has not yet been created, getI18n will create a new instance automatically.\n\n// import the function\nimport { createCustomElement, getI18n, withI18n } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// use it within a component\ncreateCustomElement(\n  'my-component',\n  withI18n(getI18n(), {\n    /* pass component creation options here */\n  })\n)"},"legacy-browsers.md":{"id":"legacy-browsers.md","title":"Legacy browsers","url":"/legacy-browsers/","excerpt":"Legacy browsers\n\nFicusJS uses modern Javascript (ES6+) but can be transpiled to work with legacy browsers.\n\nSee the examples...","body":"Legacy browsers\n\nFicusJS uses modern Javascript (ES6+) but can be transpiled to work with legacy browsers.\n\nSee the examples directory on Github."},"consuming.md":{"id":"consuming.md","title":"Modules - Consuming a module","url":"/modules/consuming/","excerpt":"Consuming a module\n\nThe following example shows how to consume a module from a shared library.\n\n// import the required FicusJS...","body":"Consuming a module\n\nThe following example shows how to consume a module from a shared library.\n\n// import the required FicusJS functions\nimport { createCustomElement, use } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import component library from a local path\nimport { module } from './path/to/component-module.esm.js'\n\n// import the components into your application\nuse(module, { renderer, html })\n\n// in your template, use the component\ncreateCustomElement('my-component', {\n  renderer,\n  render () {\n    return html`\n      \n    `\n  }\n})\n\nuse function\n\nThe use function will import a module of components into your application ready to use.\n\n// import the use function\nimport { use } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// import the renderer and html tagged template literal from the uhtml renderer\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import component module from a local path\nimport { module } from './path/to/component-module.esm.js'\n\n// import the components into your application\nuse(module, { renderer, html })\n\nThe following arguments must be provided to the use function:\n\nProperty Type Description\nmodule object The imported module\nhelpers object A helpers object for passing to components. This must contain the renderer function as a named property\n\nThe helpers object must contain the renderer function as named property. Additional helpers can be provided in the helpers object and will be passed to the module. For example; the html tagged template literal can be passed for module components to return HTML content.\n\n// pass the renderer and the html tagged template literal to the module for rendering\nuse(module, { renderer, html })"},"creating.md":{"id":"creating.md","title":"Modules - Creating a module","url":"/modules/creating/","excerpt":"Creating a module\n\nA module is a set of functions for creating components, stores and/or events.\nThis ensures just the...","body":"Creating a module\n\nA module is a set of functions for creating components, stores and/or events.\nThis ensures just the definitions will be shared without the overhead of bundling the FicusJS runtime.\n\nModules should be minified to optimise load.\n\n\n\nA single Javascript file exports a named object module exposing a create method.\nThe shared module create method will be invoked by the use function in the context of the running application and is passed a single object argument.\n\nIt is the responsibility of the create method to use the object argument to create components, stores or events (anything required by the module).\n\n// Export a module object that is invoked by the `use` function\nexport const module = {\n  create (helpers) {\n    // create stuff here\n  }\n}\n\nAsync create method\n\nYou can return a Promise from the create method that contains async operations.\n\n// use async/await\nexport const module = {\n  async create (helpers) {\n    await asyncFunction()\n  }\n}\n\n// return a Promise\nexport const module = {\n  create (helpers) {\n    return asyncFunction()\n  }\n}\n\nIf returning a Promise, the calling module must handle the response before continuing execution.\n\nWhen using the all features build\n\nWhen using the all features build dist/index.mjs, the helpers object will contain the following properties.\n\nProperty Type Description\ncreateComponent function The createComponent function\nrenderer function The renderer function for component rendering\ncreateEventBus function The createEventBus function\ncreatePersist function The createPersist function\ncreateStore function The createStore function\ngetEventBus function The getEventBus function\ngetStore function The getStore function\nuse function The use for loading modules internally\n\nAdditional arguments provided in the helpers object will be passed to the module. For example; the html tagged template literal can be passed for module components to return HTML content.\n\n// Export a module object that is invoked by the `use` function\nexport const module = {\n  create (helpers) {\n    // create stuff here\n  }\n}\n\nThe following example creates a component, a store and imports another module for use internally.\n\nimport { module as anotherModule } from './path/to/another-module.esm.js'\n\nfunction createSharedComponent (renderer, html, getStore) {\n  return {\n    renderer,\n    store: getStore('test.store'),\n    render () {\n      if (this.store.state.hideComponent) {\n        return ''\n      }\n      return html`Shared component`\n    }\n  }\n}\n\n// Export a module object that is invoked by the `use` function\nexport const module = {\n  create ({ createComponent, renderer, html, createStore, getStore, use }) {\n    // create stores\n    createStore('test.store', { /* store options */ })\n\n    // create components\n    createComponent('shared-component', createSharedComponent(renderer, html, getStore))\n\n    // import and use another module\n    use(anotherModule, { renderer, html })\n  }\n}\n\nWhen using the component build only\n\nWhen using the component only dist/component.mjs without stores and events, the helpers object argument will contain the following properties:\n\nProperty Type Description\ncreateComponent function The createComponent function\nrenderer function The renderer function for component rendering\nuse function The use function for loading modules internally\n\nAdditional arguments provided in the helpers object will be passed to the module. For example; the html tagged template literal can be passed for module components to return HTML content.\n\n// Export a module object that is invoked by the `use` function\nexport const module = {\n  create (helpers) {\n    // create components here\n  }\n}"},"css.md":{"id":"css.md","title":"Renderers - css","url":"/renderers/css/","excerpt":"css\n\nThe css tagged template literal is available in the @ficusjs/renderers package and is intended for rendering CSS styles...","body":"css\n\nThe css tagged template literal is available in the @ficusjs/renderers package and is intended for rendering CSS styles within a component.\n\nThis renderer is used in conjunction with the withStyles component extension.\n\n// import the css tagged template literal\nimport { css } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/css'\n\ncreateCustomElement(\n  'test-comp',\n  withStyles({\n    renderer,\n    styles () {\n      return css`\n        test-comp div {\n          background-color: purple;\n          color: pink\n        }\n      `\n    },\n    render () {\n      return html`\n        Some HTML content with ${someVariable}\n      `\n    }\n  })\n)"},"htm-preact.md":{"id":"htm-preact.md","title":"Renderers - htm with Preact","url":"/renderers/htm-preact/","excerpt":"htm with Preact\n\nThe htm with Preact renderer is a JSX-like renderer (no transpiler necessary) available in the...","body":"htm with Preact\n\nThe htm with Preact renderer is a JSX-like renderer (no transpiler necessary) available in the @ficusjs/renderers package.\n\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm-preact'\n\ncreateCustomElement('test-comp', {\n  renderer,\n  render () {\n    return html`\n      Some HTML content with ${someVariable}\n    `\n  }\n})"},"htm.md":{"id":"htm.md","title":"Renderers - htm","url":"/renderers/htm/","excerpt":"htm\n\nThe htm renderer is a JSX-like renderer (no transpiler necessary) available in the @ficusjs/renderers package.\n\nimport {...","body":"htm\n\nThe htm renderer is a JSX-like renderer (no transpiler necessary) available in the @ficusjs/renderers package.\n\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/htm'\n\ncreateCustomElement('test-comp', {\n  renderer,\n  render () {\n    return html`\n      Some HTML content with ${someVariable}\n    `\n  }\n})"},"lit-html.md":{"id":"lit-html.md","title":"Renderers - lit-html","url":"/renderers/lit-html/","excerpt":"lit-html\n\nThe lit-html renderer is available in the @ficusjs/renderers package.\n\n// import the renderer function and the html...","body":"lit-html\n\nThe lit-html renderer is available in the @ficusjs/renderers package.\n\n// import the renderer function and the html tagged template literal\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/lit-html'\n\ncreateCustomElement('test-comp', {\n  renderer,\n  render () {\n    return html`\n      Some HTML content with ${someVariable}\n    `\n  }\n})"},"uhtml.md":{"id":"uhtml.md","title":"Renderers - uhtml","url":"/renderers/uhtml/","excerpt":"uhtml\n\nThe uhtml renderer is available in the @ficusjs/renderers package and is the default renderer.\n\n// import the renderer...","body":"uhtml\n\nThe uhtml renderer is available in the @ficusjs/renderers package and is the default renderer.\n\n// import the renderer function and the html tagged template literal\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\ncreateCustomElement('test-comp', {\n  renderer,\n  render () {\n    return html`\n      Some HTML content with ${someVariable}\n    `\n  }\n})"},"add-matcher-to-route.md":{"id":"add-matcher-to-route.md","title":"Router - addMatcherToRoute function","url":"/router/add-matcher-to-route/","excerpt":"addMatcherToRoute function\n\nThe addMatcherToRoute function adds a matcher to a route to match a URL with parameters.\n\nconst...","body":"addMatcherToRoute function\n\nThe addMatcherToRoute function adds a matcher to a route to match a URL with parameters.\n\nconst route = {\n  path: '/hello/:username',\n  async action({ params }) {\n    const resp = await window.fetch(`/api/users/${params.username}`)\n    const user = await resp.json()\n    if (user) return ``\n    return 'hello-page'\n  }\n}\n\nconst routeWithMatcher = addMatcherToRoute(route)\n\n// check a route that contains a username\nconst url = '/hello/john'\nconst params = routeWithMatcher.matcher(url)\n// params = { username: 'john' }"},"async-routes.md":{"id":"async-routes.md","title":"Router - Async routes","url":"/router/async-routes/","excerpt":"Async Routes\n\nThe router works great with asynchronous functions out of the box:\n\nconst routes = [\n  {\n    path:...","body":"Async Routes\n\nThe router works great with asynchronous functions out of the box:\n\nconst routes = [\n  {\n    path: '/hello/:username',\n    async action({ params }) {\n      const resp = await window.fetch(`/api/users/${params.username}`)\n      const user = await resp.json()\n      if (user) return ``\n      return 'hello-page'\n    },\n  }\n]\n\nconst router = createRouter(routes, '#router-outlet')\n\nAlternatively, stick to Promises:\n\nconst routes = [\n  {\n    path: '/hello/:username',\n    action ({ params }) {\n      return window.fetch(`/api/users/${params.username}`)\n        .then(resp => resp.json())\n        .then(user => user ? `` : 'hello-page')\n    }\n  }\n]\n\nconst router = createRouter(routes, '#router-outlet')"},"context.md":{"id":"context.md","title":"Router - Context","url":"/router/context/","excerpt":"Context\n\nIn addition to a URL path string, any arbitrary data can be passed to a route action method.\n\nconst routes = [\n  {...","body":"Context\n\nIn addition to a URL path string, any arbitrary data can be passed to a route action method.\n\nconst routes = [\n  { path: '/hello', action: (context) => `` }\n]\nconst options = {\n  context: { user: 'admin' }\n}\n\nconst router = createRouter(routes, '#router-outlet', options)\n\nRouter always adds the following parameters to the context object\nbefore passing it to the resolveRoute function:\n\nrouter - Current router instance\nroute - Matched route object\npath - Matched path\nparams - Matched path and query string params, see URL Parameters section above for details"},"create-router.md":{"id":"create-router.md","title":"Router - createRouter function","url":"/router/create-router/","excerpt":"createRouter function\n\nCreate your router instance using the createRouter function passing an array of routes and an element...","body":"createRouter function\n\nCreate your router instance using the createRouter function passing an array of routes and an element selector as the router outlet:\n\n// import the function\nimport { createRouter } from 'https://cdn.skypack.dev/@ficusjs/router@3'\n\n// create list of routes\nconst routes = [\n  // routes defined here\n]\n\nconst router = createRouter(routes, '#router-outlet')\n\nWhen using the createRouter function, the following arguments can be passed:\n\nArgument Type Required Description\nroutes Array yes An array of routes\nrootOutletSelector String yes A CSS selector for the main router outlet\noptions Object  An optional set of options. See options"},"get-router.md":{"id":"get-router.md","title":"Router - getRouter function","url":"/router/get-router/","excerpt":"getRouter function\n\nThe getRouter function is a quick way to retrieve the router instance.\n\n// import the function\nimport {...","body":"getRouter function\n\nThe getRouter function is a quick way to retrieve the router instance.\n\n// import the function\nimport { getRouter } from 'https://cdn.skypack.dev/@ficusjs/router@3'\n\n// use it within a component\ncreateComponent('my-page-component', {\n  navigateTo (url) {\n    getRouter().push(url)\n  }\n})"},"getting-started.md":{"id":"getting-started.md","title":"Script loader - Getting started","url":"/script-loader/getting-started/","excerpt":"Getting started\n\nThe easiest way to try out FicusJS script loader is using a simple example.\n\nCreate an index.html file and copy...","body":"Getting started\n\nThe easiest way to try out FicusJS script loader is using a simple example.\n\nCreate an index.html file and copy the following between the `` tags.\n\n\n\n\nimport { loadScript } from 'https://cdn.skypack.dev/@ficusjs/script@2'\nconst markdownToRender = `# FicusJS script loader\n\nDynamically load ES modules and ES5 scripts.\n\n- Lazy load ES modules\n- Lazy load ES5 scripts\n- Dynamically load based on path\n- Functional programming patterns\n- Small footprint (1.3 KB gzipped for everything!)\n- No dependencies\n- Works with client-side frameworks\n`\n\n// load the ES module for marked\nloadScript('https://unpkg.com/marked@1.2.0/lib/marked.esm.js')\n  .then(mod => mod.default)\n  .then(marked => {\n    const content = document.getElementById('content')\n    content.innerHTML = marked(markdownToRender)\n  })\n\n\nAlternatively, fork this Codepen to see it in action - https://codepen.io/ducksoupdev/pen/abZbdbq\n\n\n\nThe example imports the marked ES module and converts some markdown to HTML."},"guards.md":{"id":"guards.md","title":"Router - Guards","url":"/router/guards/","excerpt":"Guards\n\nYou can guard navigations either by redirecting it or cancelling it.\n\nGlobal guards\n\nYou can use the resolveRoute option...","body":"Guards\n\nYou can guard navigations either by redirecting it or cancelling it.\n\nGlobal guards\n\nYou can use the resolveRoute option to redirect a route or cancel it:\n\n{\n  resolveRoute (context, params) {\n    // request a redirect\n    return { redirect: '/login' }\n\n    // cancel a route\n    return false\n  }\n}\n\nRoute guards\n\nYou can redirect or cancel a route from the action function:\n\n```js\nconst routes = [\n  {\n    path: '/redirect',\n    action () {\n      return { redirect: '/target' } //"},"lazy-load-views.md":{"id":"lazy-load-views.md","title":"Router - Lazy load views","url":"/router/lazy-load-views/","excerpt":"Lazy load views\n\nTo lazy load a view you can use the native ES6 import import('/path/to/script.js') within your route...","body":"Lazy load views\n\nTo lazy load a view you can use the native ES6 import import('/path/to/script.js') within your route action:\n\n{\n  path: '',\n  action: () => import('./views/home.js').then(() => 'home-page')\n}"},"location.md":{"id":"location.md","title":"Router - Location","url":"/router/location/","excerpt":"Location\n\nTo retrieve the current location, use the location property:\n\nrouter.location // retrieve the...","body":"Location\n\nTo retrieve the current location, use the location property:\n\nrouter.location // retrieve the location\nrouter.location.state // retrieve the location state"},"modes.md":{"id":"modes.md","title":"Router - Modes","url":"/router/modes/","excerpt":"Modes\n\nThere are two modes of routing available - history and hash. Modes are set using options.\n\nHistory routing\n\nA router that...","body":"Modes\n\nThere are two modes of routing available - history and hash. Modes are set using options.\n\nHistory routing\n\nA router that uses the HTML5 history API (pushState, replaceState and the popstate event) to keep your UI in sync with the URL.\n\nHash routing\n\nA router that uses the hash portion of the URL (i.e. window.location.hash) to keep your UI in sync with the URL."},"navigation.md":{"id":"navigation.md","title":"Router - Navigation","url":"/router/navigation/","excerpt":"Navigation\n\nrouter instances can be used to programmatically change the current location using the following...","body":"Navigation\n\nrouter instances can be used to programmatically change the current location using the following methods:\n\nrouter.push(path, [state])\nrouter.replace(path, [state])\nrouter.go(n)\nrouter.goBack()\nrouter.goForward()\n\nWhen using push or replace you can either specify both the URL path and state as separate arguments or include everything in a single location-like object as the first argument.\n\nA URL path or\nA location-like object with { pathname, search, hash, state }\n\n// Go to the /home route\nrouter.push('/home')\n\n// Go to the /home route with a query string\n// and some state. Location state does not appear in the URL.\nrouter.push('/home?the=query', { some: 'state' })\n\n// If you prefer, use a single location-like object to specify both\n// the URL and state. This is equivalent to the example above.\nrouter.push({\n  pathname: '/home',\n  search: '?the=query',\n  state: { some: 'state' }\n})\n\n// Go back to the previous history entry. The following\n// two lines are synonymous.\nrouter.go(-1)\nrouter.goBack()\n\nPlease note; calling router.push(path) with a path that matches the current URL will be ignored."},"options.md":{"id":"options.md","title":"Router - Options","url":"/router/options/","excerpt":"Options\n\nYou can pass an options object to the createRouter function to provide additional router configuration and...","body":"Options\n\nYou can pass an options object to the createRouter function to provide additional router configuration and context.\n\nYou can provide the following options:\n\nProperty Required Default Type Description\nmode  history string The type of URL routing to use - history or hash. The default is history which requires a back-end to serve the application. A hash router uses hashes in the URL to route and doesn't require a server back-end\nautoStart  true boolean Indicate if the router should auto-start. The default is true. If false is set, the start() method must be called to start the router\nchangeHistoryState  true boolean Indicate if the router should change the browser session history stack using window.history.replaceState and window.history.pushState. The default is true\nwarnOnMissingOutlets  false boolean Indicate if the router should log a console.warn if a named outlet cannot be found. The default is false\ncontext   object context is an object with any data which you want to pass to resolveRoute function or an action function for a matched route\nresolveRoute   function resolveRoute is a function for any custom route handling logic. For example you can define this option to work with routes in declarative manner. To render a route, this function must return either an HTML template or a Promise that resolves an HTML template. If undefined is returned, the router will attempt to match a route and call the action function if one is found\nerrorHandler   function errorHandler is a function for global error handling. Called with error and context arguments every time the route is not found or throws an error. This must return either an HTML template or a Promise that resolves an HTML template to be rendered when an error occurs\n\nPass the options object to the createRouter function:\n\nconst routes = [\n  { path: '', action: (context) => `` },\n  { path: '/one', action: (context) => `` },\n  { path: '/two', action: (context, params) => `` }\n]\n\nfunction logErrorAndRender (error) {\n  return new Promise((resolve, reject) => {\n    window.fetch('/error-logger', {\n      method: 'POST',\n      data: JSON.stringify(error),\n      headers: {\n        'Content-type': 'application/json'\n      }\n    })\n    .then(() => resolve('page-error'))\n    .catch(e => resolve(``))\n  })\n}\n\nconst options = {\n  context: { user: null },\n  resolveRoute (context, params) {\n    if (typeof context.route.action === 'function') {\n      return context.route.action(context, params)\n    }\n    return undefined\n  },\n  errorHandler (error, context) {\n    console.error(error)\n    console.info(context)\n    return error.status === 404\n      ? 'page-not-found'\n      : logErrorAndRender(error)\n  }\n}\n\nconst router = createRouter(routes, '#router-outlet', options)\n\nSetting options\n\nYou can set options at any time using the setOptions method on the router instance.\n\nFor example, this allows you to use a store as part of the router options after the store and router instances have been created.\n\nconst router = createRouter(routes, '#router-outlet')\nconst store = getStore('an-example-store')\n\n// some time later\nrouter.setOptions({\n  ...router.options, // get the existing options from the router\n  resolveRoute (context, params) {\n    if (context.path === '/logout') {\n      store.dispatch('setUserLoggedIn', false)\n      return { redirect: '/' }\n    }\n  },\n  errorHandler (error, context) {\n    console.error(error)\n    console.info(context)\n    return error.status === 404\n      ? 'page-not-found'\n      : logErrorAndRender(error)\n  }\n})"},"outlets.md":{"id":"outlets.md","title":"Router - Outlets","url":"/router/outlets/","excerpt":"Outlets\n\nThe router outlet acts as a placeholder that marks the spot where the router should display the components for that...","body":"Outlets\n\nThe router outlet acts as a placeholder that marks the spot where the router should display the components for that outlet.\n\n\n\nGiven the routes above, when the browser URL for this application becomes /one, the router matches that URL to the route path /one and displays the component as a sibling to the.\n\nRoot outlet\n\nA root outlet is mandatory when creating a router instance using the createRouter function.\n\nChild outlets\n\nViews can contain child outlets allowing components to be composed in the view dynamically based on route.\n\n\n\nRoutes can contain outlets that map outlets to components:\n\nconst routes = [\n  {\n    path: '/hello/:username',\n    action (context) {\n      // this component contains a  outlet\n      return ``\n    },\n    outlets: {\n      '#outlet-sidebar': (context) => ``\n    }\n  }\n]\n\nThe outlets object keys are CSS selectors that match an element in your view.\nEach value must be a function that returns a string for a component or a Promise that resolves a string for a component.\n\nMultiple outlets of the same name can exist and will be rendered with the same template. This is useful for displaying the same component in different locations - such as a mobile and desktop view.\n\nconst routes = [\n  {\n    path: '/hello/:username',\n    action (context) {\n      // this component contains a  outlet\n      return ``\n    },\n    outlets: {\n      '.outlet-sidebar': (context) => ``\n    }\n  }\n]\n\nSticky child outlets\n\nBy default, URL changes clear outlets ready for new routes to render content. Setting a child outlet to sticky prevents this behaviour which means the contents only get replaced if a route defines an outlet that replaces the content.\n\nTo make an outlet sticky, simply add the sticky attribute to the outlet element.\n\n\n\nresolveRoute\n\nThe resolveRoute option can return an object containing template and outlets properties:\n\n{\n  resolveRoute (context, params) {\n    return {\n      template: context.route.action(context, params), // call an existing route action for a template\n      outlets: {\n        '#bar': () => 'bar-contents'\n      }\n    }\n  }\n}"},"redirects.md":{"id":"redirects.md","title":"Router - Redirects","url":"/router/redirects/","excerpt":"Redirects\n\nYou can redirect from a route by returning a redirect object from the action function:\n\n```js\nconst routes = [\n  {\n  ...","body":"Redirects\n\nYou can redirect from a route by returning a redirect object from the action function:\n\n```js\nconst routes = [\n  {\n    path: '/redirect',\n    action () {\n      return { redirect: '/target' } //"},"routes.md":{"id":"routes.md","title":"Router - Routes","url":"/router/routes/","excerpt":"Routes\n\nEach route is a plain JavaScript object having path and either component or action properties.\n\nA route component is a...","body":"Routes\n\nEach route is a plain JavaScript object having path and either component or action properties.\n\nA route component is a tag string for a component. For example; my-page-component.\n\n{ path: '/one', component: 'page-one' }\n\nA route action must be a function that returns a string for a component or a Promise that resolves a string for a component.\nThe string can contain props that are passed to the component. For example:\n\n// render the page component with tag \n{ path: '/one', action: () => 'page-one' }\n{ path: '/one', action: () => '' } // same as above\n\n// use the route params to render the component with props\n{ path: '/one', action: (context, params) => `` }\n\nThe action function receives context and params arguments when the route matches, and the action function invoked:\n\nconst routes = [\n  { path: '/one', action: (context, params) => `` }\n]\n\ncontext is an object with any data you want to pass to an action (see Options below)\nparams is a key/value object containing URL and query string parameters matched for the route\n\nYou can define an action using different ES6 flavours:\n\n{\n  path: '/',\n  action: () => 'home-page' // inline fat-arrow function\n}\n{\n  path: '/one',\n  action () { // shortcut function declaration\n    return 'page-one'\n  }\n}\n\nAdding routes dynamically\n\nDynamically add more routes to the router using the addRoutes method.\nThe argument must be an Array using the same route format.\n\n// create list of routes\nconst routes = [\n  { path: '/one', component: 'page-one' },\n  { path: '/two', component: 'page-two' }\n]\n\nconst router = createRouter(routes, '#router-outlet')\n\n// some time later\nrouter.addRoutes([\n  { path: '/three', component: 'page-three' },\n  { path: '/four', action: () => `` }\n])\n\nNested routes\n\nEach route may have an optional children: [ ... ] property containing the list of child routes:\n\nconst routes = [\n  {\n    path: '/admin',\n    children: [\n      {\n        path: '',                        // www.example.com/admin\n        component: 'admin-page'\n      },\n      {\n        path: '/users',\n        children: [\n          {\n            path: '',                    // www.example.com/admin/users\n            component: 'user-list-page'\n          },\n          {\n            path: '/:username',          // www.example.com/admin/users/john\n            action: (context, { username }) => ``\n          }\n        ]\n      }\n    ]\n  }\n]"},"server-side-routing.md":{"id":"server-side-routing.md","title":"Router - Server-side routing","url":"/router/server-side-routing/","excerpt":"Server-side routing\n\nIf you are using the history routing mode, the router uses the HTML History API to handle client-side...","body":"Server-side routing\n\nIf you are using the history routing mode, the router uses the HTML History API to handle client-side routing. This breaks when the user refreshes a URL that isn't handled server-side.\nTo ensure the client can handle the URL, you need server-side logic to route to the client.\n\nFor example, when using NodeJS and Express:\n\napp.get('*', function (req, res) {\n  res.sendFile(__dirname + '/index.html')\n})\n\nFull page reloads\n\nIf the browser reloads to a route that is not at root level, for example; /user/matt/tasks, the browser will need to load resources relative to the root.\nTo ensure this happens, add a base tag to the head of your index page:"},"starting-programmatically.md":{"id":"starting-programmatically.md","title":"Router - Starting programmatically","url":"/router/starting-programmatically/","excerpt":"Starting programmatically\n\nBy default, the router will auto-start. This adds a listener to the History API to handle URL...","body":"Starting programmatically\n\nBy default, the router will auto-start. This adds a listener to the History API to handle URL changes.\n\nIf you want to programmatically start the router you can call the start() method on the router instance.\nYou can optionally pass a location object or string path to the start method too for that route to be rendered.\n\n// create a router but do not auto-start\nconst router = createRouter(routes, '#router-outlet', { autoStart: false })\n\n// some time later\nrouter.start()\n\n// you can pass a location object or string path to the start method too for that route to be rendered\nrouter.start('/home')"},"url-parameters.md":{"id":"url-parameters.md","title":"Router - URL parameters","url":"/router/url-parameters/","excerpt":"URL Parameters\n\nNamed route parameters are captured and added to context.params.\n\nconst routes = [\n  { path: '/hello/:username',...","body":"URL Parameters\n\nNamed route parameters are captured and added to context.params.\n\nconst routes = [\n  { path: '/hello/:username', action: (context) => `` }\n]\n\nconst router = createRouter(routes, '#router-outlet')\n\nAlternatively, captured parameters can be accessed via the second argument\nto an action method like so:\n\nconst routes = [\n  { path: '/hello/:username', action: (context, { username }) => `` }\n]\n\nconst router = createRouter(routes, '#router-outlet')\n\nQuery string and hash parameters will be added to context.params for convenience."},"add-xstate-service.md":{"id":"add-xstate-service.md","title":"Finite state machines and statecharts - addXStateService function","url":"/state-machines/add-xstate-service/","excerpt":"addXStateService function\n\nThe addXStateService function adds an XState service (a running instance of a state machine) that can...","body":"addXStateService function\n\nThe addXStateService function adds an XState service (a running instance of a state machine) that can be used within components.\nIt is ideal for use in conjunction with the full XState library which supports complex state machines and statecharts.\n\nWhen using the addXStateService function, you must pass two parameters:\n\nservice key (for example an.example.service) - keys must be unique and are used to retrieve services later\nthe service created with the interpret function\n\n// import full XState library\nimport { createMachine, interpret } from 'https://cdn.skypack.dev/xstate'\n\n// import the required function\nimport { addXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst definition = {\n  /* define the machine definition */\n}\n\nconst options = {\n  /* define options like actions, guards etc */\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)\n\n// interpret the state machine to create a service\nconst service = interpret(machine)\n\n// add the service\naddXStateService('toggle.service', service)\n\nA service can then be passed to as many components as required using the withXStateService function."},"assign.md":{"id":"assign.md","title":"Finite state machines and statecharts - assign function","url":"/state-machines/assign/","excerpt":"assign function\n\nThe assign function is used to update data within a state machine.\n\nState machines can hold data known as...","body":"assign function\n\nThe assign function is used to update data within a state machine.\n\nState machines can hold data known as extended state using a context object. This makes the state machine useful in applications where storage of data is required in addition to the finite states.\n\nimport { assign, createMachine } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst definition = {\n  context: { amount: 0 },\n  id: 'glass',\n  initial: 'empty',\n  states: {\n    empty: {\n      on: {\n        FILL: {\n          actions: 'addWater',\n          target: 'filling'\n        }\n      }\n    },\n    filling: {\n      always: {\n        cond: 'glassIsFull',\n        target: 'full'\n      },\n      on: {\n        FILL: {\n          actions: 'addWater',\n          target: 'filling',\n          internal: false\n        }\n      }\n    },\n    full: {}\n  }\n}\n\nconst options = {\n  actions: {\n    addWater: assign({\n      amount: (context, event) => context.amount + 1\n    })\n  },\n  guards: {\n    glassIsFull (context, event) {\n      return context.amount >= 10\n    }\n  }\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)"},"create-machine.md":{"id":"create-machine.md","title":"Finite state machines and statecharts - createMachine function","url":"/state-machines/create-machine/","excerpt":"createMachine function\n\nThe createMachine function is used to define a state machine.\n\nimport { createMachine } from...","body":"createMachine function\n\nThe createMachine function is used to define a state machine.\n\nimport { createMachine } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst machine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: { on: { TOGGLE: 'active' } },\n    active: { on: { TOGGLE: 'inactive' } }\n  }\n})\n\nOptions\n\nActions and guards can be implemented within an options object passed as the second argument to createMachine.\n\nactions - the mapping of action names to their implementation\nguards - the mapping of transition guard (cond) names to their implementation\n\nconst definition = {\n  context: { amount: 0 },\n  id: 'glass',\n  initial: 'empty',\n  states: {\n    empty: {\n      on: {\n        FILL: {\n          actions: 'addWater',\n          target: 'filling'\n        }\n      }\n    },\n    filling: {\n      always: {\n        cond: 'glassIsFull',\n        target: 'full'\n      },\n      on: {\n        FILL: {\n          actions: 'addWater',\n          target: 'filling',\n          internal: false\n        }\n      }\n    },\n    full: {}\n  }\n}\n\nconst options = {\n  actions: {\n    addWater: assign({\n      amount: (context, event) => context.amount + 1\n    })\n  },\n  guards: {\n    glassIsFull (context, event) {\n      return context.amount >= 10\n    }\n  }\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)"},"create-xstate-service.md":{"id":"create-xstate-service.md","title":"Finite state machines and statecharts - createXStateService function","url":"/state-machines/create-xstate-service/","excerpt":"createXStateService function\n\nThe createXStateService function creates an XState service (a running instance of a state machine)...","body":"createXStateService function\n\nThe createXStateService function creates an XState service (a running instance of a state machine) that can be used within components.\n\nA service is created using the createMachine function first followed by the createXStateService function. It is an instance created using the @xstate/fsm package.\n\nThe createXStateService function takes four arguments:\n\nservice key (for example an.example.service) - keys must be unique and are used to retrieve services later (required)\nmachine created with the createMachine function (required)\nan object of getter functions (optional)\na persistence string, object or custom class (optional)\n\nimport { createMachine, createXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst definition = {\n  /* define the machine definition */\n}\n\nconst options = {\n  /* define options like actions, guards etc */\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)\n\n// interpret the state machine to create a service\nconst service = createXStateService('toggle.service', machine)\n\nA service can then be passed to as many components as required using the withXStateService function.\n\nGetters\n\nGetters are useful if you want to return a projection of the extended state (the state machine context is the extended state). A projection is a shape derived from the state.\n\nGetters are memoized functions which means the result of the getter is cached for subsequent executions. This is useful when creating projections from large sets of data. State changes will automatically reset the getter cache.\n\nTo provide getters for creating projections, create an object containing functions and pass it to the createXStateService function as the third argument.\n\nconst getters = {\n  isGlassFull (context) {\n    return context.amount >= 10\n  },\n  remaining (context) {\n    return 10 - context.amount\n  }\n}\n\n// interpret the state machine to create a service\nconst service = createXStateService('toggle.service', machine, getters)\n\nPersistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will re-hydrate your state machine on initialisation.\n\nPassing a string as the persistence argument provides a namespace for persisting the state.\n\nconst service = createXStateService('toggle.service', machine, getters, 'food')\n\ncreatePersist function\n\nYou can optionally save state to window.localStorage (for persistence across browser sessions) using the createPersist function:\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = createXStateService('toggle.service', machine, getters, createPersist('food', 'local'))\n\nWhen using the createPersist function, the following arguments must be supplied:\n\nArgument Type Required Description\nnamespace string true The unique namespace for the store\nstorage string true The storage mechanism to use - either local for window.localStorage or session for window.sessionStorage (default)\noptions object  Persistence options. See options below.\n\nOptions\n\nOptions can be provided when creating persistence.\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = createXStateService('toggle.service', machine, getters, createPersist('food', 'local', {\n  clearOnReload: true,\n  saveState (state) {\n    return {\n      // only save the state value\n      value: state.value\n    }\n  }\n}))\n\noptions.clearOnReload\n\nSetting options.clearOnReload to true will detect the browser reload state using\nthe window.performance API and clear the persistence\nif a reload type is detected.\n\ncreatePersist('food', 'local', {\n  clearOnReload: true\n})\n\noptions.saveState\n\nSetting options.saveState provides a way to persist specific data different to that of the store state.\nThis is useful when the store state contains functions or other data that cannot be serialised into a string when saved\nto window.sessionStorage or window.localStorage.\n\ncreatePersist('food', 'local', {\n  saveState (state) {\n    return {\n      // return properties of state to persist\n    }\n  }\n})\n\nThe saveState function is passed the current state and must return an object of data to be serialised into a string.\n\nCustom persistence\n\nYou can provide a custom class and persist your application state in whichever way you choose.\n\nFour methods must be implemented:\n\nMethod Description\nsetState(state) Save the state in the persistence store\ngetState() Retrieve the state from the persistence store\nlastUpdated() Retrieve the last updated time of the state in milliseconds since the Unix Epoch\nremoveState() Remove the state from the persistence store\n\nclass MyCustomPersist {\n  setState (state) {\n    // set the state\n  }\n\n  getState () {\n    // get the state\n  }\n\n  lastUpdated () {\n    // get the last updated time in milliseconds since the Unix Epoch\n  }\n\n  removeState () {\n    // remove the state - this is called by default when setState is null\n  }\n}\n\nconst service = createXStateService('toggle.service', machine, getters, new MyCustomPersist())"},"defining-state-machines.md":{"id":"defining-state-machines.md","title":"Finite state machines and statecharts - Defining state machines","url":"/state-machines/defining-state-machines/","excerpt":"Defining state machines\n\nFinite state machines and statecharts are a visual language used to describe the states in a...","body":"Defining state machines\n\nFinite state machines and statecharts are a visual language used to describe the states in a process.\n\nYou may have used similar diagrams in the past to design user flows, plan databases or map app architecture. Statecharts are another way of using boxes and arrows to represent flows, but with FicusJS these flows are also executable code that can be used to control the logic in your applications.\n\nThis guide covers the basics of statecharts in a beginner-friendly way, including:\n\nStates\nTransitions and events\nInitial state\nFinal state\nPlanning statecharts\nActions\nFurther reading\n\nStates\n\nThe states are represented by rounded rectangle boxes. To draw a statechart for the process of a dog, there are two states that would first come to mind:\n\n\n\nA dog is always asleep or awake. The dog can’t be asleep and awake at the same time, and it’s impossible for the dog to be neither asleep nor awake. There’s only these two states, a precisely limited, finite number of states.\n\nTransitions and events\n\nHow the dog goes between asleep and awake is through transitions, which are symbolized by an arrow pointing from one state to the next state in the process’s sequence.\n\n\n\nA transition is caused by an event that results in the change of state. Transitions are labelled with their events.\n\nTransitions and events are deterministic. Deterministic means that each transition and event always points to the same next state, and always produces the same result from their given starting condition, every time the process is run. Dogs never wake up to become asleep or fall asleep to become awake.\n\nThis tiny dog process, with its two finite states and two transitions is a Finite State Machine. A state machine is used to describe the behavior of something. The machine describes the thing’s states and the transitions between those states. It’s a Finite State Machine because it has a finite number of states. (Sometimes abbreviated to FSM by folks who love jargon).\n\nInitial state\n\nAny process that has states will have an initial state, the default state the process exists in until an event happens to change the process’s state.\n\nThe initial state is represented by a filled circle with an arrow pointing from the circle to the initial state.\n\n\n\nUsing a statechart to describe the process of walking the dog, the initial state would be waiting to walk.\n\nFinal state\n\nMost processes with states will have a final state, the last state when the process is finished. The final state is represented by a double border on the state’s rounded rectangle box.\n\nIn the dog walking statechart, the final state would be walk complete.\n\n\n\nPlanning statecharts\n\nOne of the benefits of statecharts is that, in the process of putting a statechart together, you explore all the possible states in your process. This exploration will help you avoid bugs and errors in your code as you’re more likely to cover all the eventualities.\n\nAnd because statecharts are executable, they can behave as both the diagram and the code, making it less likely that you’ll introduce differences or bugs interpreting between the diagramming and coding environments.\n\nPlanning a statechart for a login machine\n\nTo draw a statechart for a login machine, start by listing the basic events in the process. Think about what your login process will do:\n\nlog in\nlog out\n\nThen list the states that exist as a result of those events:\n\nlogged in\nlogged out\n\nOnce there’s some events and states, there’s the beginnings of a statechart.\n\n\n\nDon’t forget the initial state. In this case, the logged out state is the initial state, as any new user would come to the process logged out.\n\nActions\n\nA statechart is used to set off actions in the system outside of the statechart. Actions are also commonly known as effects or side-effects. “Side effects” sounds like a negative or unimportant term, but setting off actions is the primary purpose in using statecharts.\n\nActions are events that have no impact or consequences for the rest of the sequence, the event is just triggered and the sequence moves on to the next step in the process. For example, the login statechart might execute actions that change the user interface.\n\nAn action can be fired upon entering or exiting a state, or on a transition. An action on a state is included inside the state’s container with an “entry /” or “exit /” label depending on whether the action should be fired on entry or exit from the state.\n\nFurther reading\n\nTo find out more about Statecharts and state machines using XState, visit the docs:\n\nhttps://xstate.js.org/docs/"},"get-xstate-service.md":{"id":"get-xstate-service.md","title":"Finite state machines and statecharts - getXStateService function","url":"/state-machines/get-xstate-service/","excerpt":"getXStateService function\n\nThe getXStateService function is a quick way to retrieve a finite state machine or statechart service...","body":"getXStateService function\n\nThe getXStateService function is a quick way to retrieve a finite state machine or statechart service created using createXStateService.\n\n// import the function\nimport { getXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\n// retrieve a store instance\nconst service = getXStateService('toggle.service')\n\nA single service can be attached to multiple components that react to state changes."},"interpret.md":{"id":"interpret.md","title":"Finite state machines and statecharts - interpret function","url":"/state-machines/interpret/","excerpt":"interpret function\n\nThe interpret function creates an instance of an interpreted machine, also known as a service. This is a...","body":"interpret function\n\nThe interpret function creates an instance of an interpreted machine, also known as a service. This is a stateful representation of the running machine, which you can subscribe to, send events to, start, and stop.\n\nThe interpret function takes three arguments:\n\nmachine created with the createMachine function (required)\nan object of getter functions (optional)\na persistence string, object or custom class (optional)\n\nimport { createMachine, interpret } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst definition = {\n  /* define the machine definition */\n}\n\nconst options = {\n  /* define options like actions, guards etc */\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)\n\n// interpret the state machine to create a service\nconst service = interpret(machine)\n\nA created service can then be passed to as many components as required using the withXStateService function.\n\nGetters\n\nGetters are useful if you want to return a projection of the extended state (the state machine context is the extended state). A projection is a shape derived from the state.\n\nGetters are memoized functions which means the result of the getter is cached for subsequent executions. This is useful when creating projections from large sets of data. State changes will automatically reset the getter cache.\n\nTo provide getters for creating projections, create an object containing functions and pass it to the interpret function.\n\nconst getters = {\n  isGlassFull (context) {\n    return context.amount >= 10\n  },\n  remaining (context) {\n    return 10 - context.amount\n  }\n}\n\n// interpret the state machine to create a service\nconst service = interpret(machine, getters)\n\nThe interpret function extends the one provided by the @xstate/fsm package. The decorated function extends to provide the getters feature.\n\nPersistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will re-hydrate your state machine on initialisation.\n\nPassing a string as the persistence argument provides a namespace for persisting the state.\n\nconst service = interpret(machine, getters, 'food')\n\ncreatePersist function\n\nYou can optionally save state to window.localStorage (for persistence across browser sessions) using the createPersist function:\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = interpret(machine, getters, createPersist('food', 'local'))\n\nWhen using the createPersist function, the following arguments must be supplied:\n\nArgument Type Required Description\nnamespace string true The unique namespace for the store\nstorage string true The storage mechanism to use - either local for window.localStorage or session for window.sessionStorage (default)\noptions object  Persistence options. See options below.\n\nOptions\n\nOptions can be provided when creating persistence.\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = interpret(machine, getters, createPersist('food', 'local', {\n  clearOnReload: true,\n  saveState (state) {\n    return {\n      // only save the state value\n      value: state.value\n    }\n  }\n}))\n\noptions.clearOnReload\n\nSetting options.clearOnReload to true will detect the browser reload state using\nthe window.performance API and clear the persistence\nif a reload type is detected.\n\ncreatePersist('food', 'local', {\n  clearOnReload: true\n})\n\noptions.saveState\n\nSetting options.saveState provides a way to persist specific data different to that of the store state.\nThis is useful when the store state contains functions or other data that cannot be serialised into a string when saved\nto window.sessionStorage or window.localStorage.\n\ncreatePersist('food', 'local', {\n  saveState (state) {\n    return {\n      // return properties of state to persist\n    }\n  }\n})\n\nThe saveState function is passed the current state and must return an object of data to be serialised into a string.\n\nCustom persistence\n\nYou can provide a custom class and persist your application state in whichever way you choose.\n\nFour methods must be implemented:\n\nMethod Description\nsetState(state) Save the state in the persistence store\ngetState() Retrieve the state from the persistence store\nlastUpdated() Retrieve the last updated time of the state in milliseconds since the Unix Epoch\nremoveState() Remove the state from the persistence store\n\nclass MyCustomPersist {\n  setState (state) {\n    // set the state\n  }\n\n  getState () {\n    // get the state\n  }\n\n  lastUpdated () {\n    // get the last updated time in milliseconds since the Unix Epoch\n  }\n\n  removeState () {\n    // remove the state - this is called by default when setState is null\n  }\n}\n\nconst service = interpret(machine, getters, new MyCustomPersist())"},"with-xstate-service.md":{"id":"with-xstate-service.md","title":"Finite state machines and statecharts - withXStateService function","url":"/state-machines/with-xstate-service/","excerpt":"withXStateService function\n\nThe withXStateService function extends a component to integrate an XState service (created with...","body":"withXStateService function\n\nThe withXStateService function extends a component to integrate an XState service (created with either createXStateService or interpret functions) for managing application or component state.\n\nThe service is an interpreter responsible for interpreting the state machine/statechart, parsing and executing it in a runtime environment.\n\nThe service is provided to the withXStateService function to automatically subscribe to state changes and trigger component updates.\n\n// import XState functions\nimport { createMachine, createXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\n// import the html tagged template literal and renderer from htm\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import the custom element creator function\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\n// import the withXStateService function\nimport { withXStateService } from 'https://cdn.skypack.dev/ficusjs@6/with-xstate-service'\n\n// create a state machine\nconst machine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: { on: { TOGGLE: 'active' } },\n    active: { on: { TOGGLE: 'inactive' } }\n  }\n})\n\n// interpret the state machine to create a service\nconst service = createXStateService('toggle.service', machine)\n\ncreateCustomElement(\n  'toggle-xstate-machine',\n  withXStateService(service, {\n    renderer,\n    onChange () {\n      this.fsm.send('TOGGLE')\n    },\n    render () {\n      let input = html``\n      if (this.fsm.state.matches('active')) {\n        input = html``\n      }\n      return html`\n        ${input}\n        Horns\n      `\n    }\n  })\n)\n\ncreateCustomElement(\n  'toggle-xstate-machine-view',\n  withXStateService(service, {\n    renderer,\n    render () {\n      return html`\n        Current state: ${this.fsm.state.value}\n      `\n    }\n  })\n)\n\nXState\n\nXState is a library for creating, interpreting, and executing finite state machines and statecharts, as well as managing invocations of those machines as actors.\n\nTo find out more visit https://xstate.js.org/docs/\n\nThe withXStateService works with the full XState library when creating state machine services.\n\n// import XState lib\nimport { createMachine, interpret } from 'https://cdn.skypack.dev/xstate'\n\n// import the html tagged template literal and renderer from htm\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/uhtml'\n\n// import the custom element creator function\nimport { createCustomElement } from 'https://cdn.skypack.dev/ficusjs@6/custom-element'\n\n// import the withXStateService function\nimport { withXStateService } from 'https://cdn.skypack.dev/ficusjs@6/with-xstate-service'\n\n// create a state machine\nconst machine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: { on: { TOGGLE: 'active' } },\n    active: { on: { TOGGLE: 'inactive' } }\n  }\n})\n\n// interpret the state machine to create a service\nconst service = interpret(machine)\n\ncreateCustomElement(\n  'toggle-xstate-machine',\n  withXStateService(service, {\n    renderer,\n    onChange () {\n      this.fsm.send('TOGGLE')\n    },\n    render () {\n      let input = html``\n      if (this.fsm.state.matches('active')) {\n        input = html``\n      }\n      return html`\n        ${input}\n        Horns\n      `\n    }\n  })\n)"},"wrap-xstate-service.md":{"id":"wrap-xstate-service.md","title":"Finite state machines and statecharts - wrapXStateService function","url":"/state-machines/wrap-xstate-service/","excerpt":"wrapXStateService function\n\nThe wrapXStateService function wraps an XState service (a running instance of a state machine) that...","body":"wrapXStateService function\n\nThe wrapXStateService function wraps an XState service (a running instance of a state machine) that can be used within components.\nIt is ideal for use in conjunction with the full XState library which supports complex state machines and statecharts.\n\nThe wrapXStateService function takes three arguments:\n\nthe service created with the interpret function (required)\nan object of getter functions (optional)\na persistence string, object or custom class (optional)\n\n// import full XState library\nimport { createMachine, interpret } from 'https://cdn.skypack.dev/xstate'\n\n// import the required function\nimport { wrapXStateService } from 'https://cdn.skypack.dev/ficusjs@6/xstate-service'\n\nconst definition = {\n  /* define the machine definition */\n}\n\nconst options = {\n  /* define options like actions, guards etc */\n}\n\n// create the state machine\nconst machine = createMachine(definition, options)\n\n// interpret the state machine to create a service\nconst serviceInstance = interpret(machine)\n\n// add the service\nwrapXStateService(service)\n\nThe wrapped service can then be passed to as many components as required using the withXStateService function.\n\nGetters\n\nGetters are useful if you want to return a projection of the extended state (the state machine context is the extended state). A projection is a shape derived from the state.\n\nGetters are memoized functions which means the result of the getter is cached for subsequent executions. This is useful when creating projections from large sets of data. State changes will automatically reset the getter cache.\n\nTo provide getters for creating projections, create an object containing functions and pass it to the wrapXStateService function as the second argument.\n\nconst getters = {\n  isGlassFull (context) {\n    return context.amount >= 10\n  },\n  remaining (context) {\n    return 10 - context.amount\n  }\n}\n\n// wrap the XState service instance and extend it with getters\nconst service = wrapXStateService(serviceInstance, getters)\n\nPersistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will re-hydrate your state machine on initialisation.\n\nPassing a string as the persistence argument provides a namespace for persisting the state.\n\nconst service = wrapXStateService(serviceInstance, getters, 'food')\n\ncreatePersist function\n\nYou can optionally save state to window.localStorage (for persistence across browser sessions) using the createPersist function:\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = wrapXStateService(serviceInstance, getters, createPersist('food', 'local'))\n\nWhen using the createPersist function, the following arguments must be supplied:\n\nArgument Type Required Description\nnamespace string true The unique namespace for the store\nstorage string true The storage mechanism to use - either local for window.localStorage or session for window.sessionStorage (default)\noptions object  Persistence options. See options below.\n\nOptions\n\nOptions can be provided when creating persistence.\n\nimport { createPersist } from 'https://cdn.skypack.dev/ficusjs@6'\n\nconst service = wrapXStateService(serviceInstance, getters, createPersist('food', 'local', {\n  clearOnReload: true,\n  saveState (state) {\n    return {\n      // only save the state value\n      value: state.value\n    }\n  }\n}))\n\noptions.clearOnReload\n\nSetting options.clearOnReload to true will detect the browser reload state using\nthe window.performance API and clear the persistence\nif a reload type is detected.\n\ncreatePersist('food', 'local', {\n  clearOnReload: true\n})\n\noptions.saveState\n\nSetting options.saveState provides a way to persist specific data different to that of the store state.\nThis is useful when the store state contains functions or other data that cannot be serialised into a string when saved\nto window.sessionStorage or window.localStorage.\n\ncreatePersist('food', 'local', {\n  saveState (state) {\n    return {\n      // return properties of state to persist\n    }\n  }\n})\n\nThe saveState function is passed the current state and must return an object of data to be serialised into a string.\n\nCustom persistence\n\nYou can provide a custom class and persist your application state in whichever way you choose.\n\nFour methods must be implemented:\n\nMethod Description\nsetState(state) Save the state in the persistence store\ngetState() Retrieve the state from the persistence store\nlastUpdated() Retrieve the last updated time of the state in milliseconds since the Unix Epoch\nremoveState() Remove the state from the persistence store\n\nclass MyCustomPersist {\n  setState (state) {\n    // set the state\n  }\n\n  getState () {\n    // get the state\n  }\n\n  lastUpdated () {\n    // get the last updated time in milliseconds since the Unix Epoch\n  }\n\n  removeState () {\n    // remove the state - this is called by default when setState is null\n  }\n}\n\nconst service = wrapXStateService(serviceInstance, getters, new MyCustomPersist())"},"stores.md":{"id":"stores.md","title":"Stores","url":"/stores/","excerpt":"Stores Deprecated\n\nStores have been replaced with application state which is a simpler, less convoluted way of working with...","body":"Stores Deprecated\n\nStores have been replaced with application state which is a simpler, less convoluted way of working with stores.\n\n\nFicusJS provides a function for creating fast, lightweight stores for application state.\n\nTo store application state outside of components and have them react to change, you can create a store which is shared across multiple components.\n\nExample\n\nImport the createStore function into your Javascript main file:\n\nmain.js\n\nimport { createStore } from 'https://cdn.skypack.dev/ficusjs@6'\n\nCreate a new store instance with actions, mutations and initialState:\n\nmain.js\n\nconst store = createStore('an.example.store', {\n  ttl: 5,\n  initialState: {\n    count: 0\n  },\n  actions: {\n    increment (context, payload) {\n      context.commit('increment', payload)\n    }\n  },\n  mutations: {\n    increment (state, payload) {\n      state.count = payload\n      return state\n    }\n  },\n  getters: {\n    max (state) {\n      return Math.max(state.count) * 1000\n    }\n  }\n})\n\ncreateStore function\n\nWhen using the createStore function, you must pass two parameters:\n\nstore key (for example an.example.store) - keys must be unique and are used to retrieve stores later\nan object that defines the properties of the store\n\nThe following properties can be used when creating stores:\n\nProperty Type Description\ninitialState object The initial state of the store\nactions object Contains one or more action functions that are dispatched to eventually mutate state\nmutations object Contains one or more mutation functions that set values and return new state\ngetters object Contains one or more getter functions that return state projections\nrouter object A router instance for use in actions where changing URL is required\npersist string or object If persistence is required (between reloads), provide a unique namespace string for saving the store to window.sessionStorage\nttl number Limit the lifetime of the data in the store by setting a time to live in seconds. Once the amount of seconds has elapsed, the store resets back to the initialState values\n\ngetStore function\n\nThe getStore function is a quick way to retrieve a store.\n\n// import the function\nimport { getStore } from 'https://cdn.skypack.dev/ficusjs@6'\n\n// retrieve a store instance\nconst storeInstance = getStore('my.another.store')\n\nState\n\nThe state tree is a single object that can contain whatever data you want. It's guarded by a Proxy\nwhich keeps an eye on things for you and tells the store if something has been modified.\n\nReading state\n\nYou can read a value from state once the instance has been created:\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  ...\n})\n\n// Log the title of the above state example\nconsole.log(store.state.title)\n\nActions\n\nTo modify state, you need to dispatch an action.\n\nActions are quite similar to mutations, but they can contain async operations such as fetching data. The end-goal of an action is to commit one or more mutations.\n\n// Create a store with actions\nconst store = createStore('an.example.store', {\n  actions: {\n    updateTitle (context, payload) {\n      context.commit('setTitle', payload.text)\n    }\n  }\n})\n\nDispatch\n\nThe dispatch method is part of the store object and runs actions for you. You can dispatch wherever there's a reference to your store:\n\n// Dispatch the `updateTitle` action to update the title\nstore.dispatch('updateTitle', { text: 'The new text for the title' })\n\nThe dispatch method takes two parameters:\n\nactionKey is the string name of your action\npayload is the data that you want to pass along to your action\n\nMutations\n\nTo actually modify the state, a mutation will take over.\n\nMutations provide a synchronous method of mutating state. They have one job and one job only: mutate the state and return it.\n\n// Create a store with actions\nconst store = createStore('an.example.store', {\n  mutations: {\n    setTitle (state, payload) {\n      state.title = payload\n      return state\n    }\n  }\n})\n\nThe setTitle method has two parameters:\n\nstate is the current version of your store's state before this mutation\npayload is the data that was passed in by your action\n\nMutations like this should be as simple as possible and only mutate the state. Anything more complex should be done at an action level.\n\nCommit\n\nThe commit method is part of the store object and runs mutations for you.\n\n// Run the `setTitle` mutation to set the state\ncontext.commit('setTitle', payload)\n\nThe commit method takes two parameters:\n\nmutationKey is the string name of your mutation\npayload is the data that you want to pass along to your mutation\n\nGetters\n\nGetters are useful if you want to return a projection of the state. A projection is a shape derived from the state.\n\nThey are memoized functions which means the result of the getter is cached for subsequent executions. This is useful when creating projections from large sets of data.\nSetting state will automatically reset the getter cache.\n\nFor example, given an array of objects, a getter can return a filtered set of objects:\n\n// Create a store with actions\nconst store = createStore('an.example.store', {\n  initialState: {\n    people: [\n      { name: 'Bill', status: 'Active' },\n      { name: 'Ted', status: 'Active' },\n      { name: 'Grim Reaper', status: 'Disabled' }\n    ]\n  },\n  getters: {\n    activePeople (state) {\n      return state.people.filter(p => p.state === 'Active')\n    }\n  }\n})\n\nconst activeOnes = store.getters.activePeople\n// [{ name: 'Bill', status: 'Active' }, { name: 'Ted', status: 'Active' }]\n\nPassing arguments to getters\n\nIf you want to pass arguments to getters for specific filtering, you can return a function as a getter:\n\n{\n  getters: {\n    timesBy (state) {\n      return (amount) => state.count * amount\n    }\n  }\n}\n\nconst total = store.getters.timesBy(20)\n// given a state.count value of 2, total will be 40\n\nSubscribing to store changes\n\nIf you want to be notified whenever the store state changes, you can use the subscribe method to register a callback function.\nThis method returns a function which can be invoked later for unsubscription.\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  ...\n})\n\n// Subscribe to changes in the store\nconst unsubscribe = store.subscribe(() => {\n  // this callback is invoked whenever the store changes\n  console.log('Store has changed!')\n})\n\n// Unsubscribe later\nunsubscribe()\n\nClearing the store\n\nTo clear a store and reset back to the initial state, use the clear() method.\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  ...\n})\n\n// clear the store and reset back to the initial state\nstore.clear()\n\n// you can also clear without notifying subscribers\nstore.clear(false)\n\nTransactions\n\nA transaction is a sequence of operations performed (using one or more actions/mutations) on a store as a single logical unit of work.\nThe transaction can be either all committed (applied to the store) or all rolled back (undone from the store).\n\n// Begin a transaction\nstore.begin()\n\ntry {\n  // Dispatch the `updateTitle` action to update the title\n  store.dispatch('updateTitle', { text: 'The new text for the title' })\n\n  // Commit a text change\n  store.commit('setText', 'example')\n\n  // Apply the transaction to the store and notify subscribers to re-render\n  store.end()\n} catch (e) {\n  // Rollback the transaction changes\n  store.rollback()\n}\n\nbegin method\n\nThe begin method starts a transaction.\n\nend method\n\nThe end method ends the transaction and notifies subscribers that the store state has changed.\n\nrollback method\n\nThe rollback method rolls back the store state changes carried out within the transaction.\nThis is used if an error occurs, and the state needs to be reset.\n\nMultiple stores\n\nYou can create as many stores as you want to separate your application state.\n\nManage multiple store instances with an Object\n\nSimply create a Javascript Object containing multiple store instances and then pass specific instances to your components.\n\nYou can also pass this object to a component and have it reacting to all store instances.\n\n// Create a number of stores\nconst allStores = {\n  food: createStore('my.food.store', { ... }),\n  drinks: createStore('my.drinks.store', { ... }),\n  snacks: createStore('my.snacks.store', { ... })\n}\n\n// Pass a relevant store to a component\ncreateCustomElement(\n  'my-component',\n  withStore(allStores.drinks, {\n    ...\n  })\n)\n\n// Or pass all the stores to a component\ncreateCustomElement(\n  'my-component',\n  withStore(allStores, {\n    ...\n  })\n)\n\n// Or just pass the required stores to a component\ncreateCustomElement(\n  'my-component',\n  withStore({\n    food: allStores.food,\n    snacks: allStores.snacks\n  }, {\n    ...\n  })\n)\n\nTransactions using an object of stores\n\nTo perform transactions across a set of stores, create methods to co-ordinate the transaction methods.\n\n// A helper function for testing a store instance\nfunction isStore (store) {\n  return store.subscribe && typeof store.subscribe === 'function'\n}\n\n// Create a number of stores\nconst allStores = {\n  food: createStore('my.food.store', { ... }),\n  drinks: createStore('my.drinks.store', { ... }),\n  snacks: createStore('my.snacks.store', { ... }),\n  begin () {\n    Object.values(this).forEach(v => isStore(v) && v.begin())\n  },\n  end () {\n    Object.values(this).forEach(v => isStore(v) && v.end())\n  },\n  rollback () {\n    Object.values(this).forEach(v => isStore(v) && v.rollback())\n  }\n}\n\nClearing multiple stores\n\nYou can clear multiple stores using custom methods.\n\n// A helper function for testing a store instance\nfunction isStore (store) {\n  return store.subscribe && typeof store.subscribe === 'function'\n}\n\n// Create a number of stores\nconst allStores = {\n  food: createStore('my.food.store', { ... }),\n  drinks: createStore('my.drinks.store', { ... }),\n  snacks: createStore('my.snacks.store', { ... }),\n  clear (notifySubscribers = true) {\n    Object.values(this).forEach(v => isStore(v) && v.clear(notifySubscribers))\n  }\n}\n\nSingleton store\n\nIf you want a single instance of a store without having to pass variables around, you can use the singleton pattern to create an instance that can be imported into individual files.\nSimply export a const and it will be treated as a singleton.\n\n// create a single singleton store\nexport const store = createStore('an.example.store', { ... })\n\n// create multiple stores in a singleton\nexport const allStores = {\n  food: createStore('my.food.store', { ... }),\n  drinks: createStore('my.drinks.store', { ... }),\n  snacks: createStore('my.snacks.store', { ... })\n}\n\nPersistence\n\nTo survive hard refreshes from the user, your state can be persisted to sessionStorage automatically.\nThis will re-hydrate your store on initialisation.\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  persist: 'food' // this must be a unique namespace for the store\n})\n\ncreatePersist function\n\nYou can optionally save state to window.localStorage (for persistence across browser sessions) using the createPersist function:\n\nimport { createStore, createPersist } from 'https://cdn.skypack.dev/ficusjs'\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  persist: createPersist('food', 'local')\n})\n\nWhen using the createPersist function, the following arguments must be supplied:\n\nArgument Type Description\nnamespace string The unique namespace for the store\nstorage string The storage mechanism to use - either local for window.localStorage or session for window.sessionStorage (default)\n\nCustom persistence\n\nYou can provide a custom class and persist your application state in whichever way you choose.\n\nFour methods must be implemented:\n\nMethod Description\nsetState(state) Save the state in the persistence store\ngetState() Retrieve the state from the persistence store\nlastUpdated() Retrieve the last updated time of the state in milliseconds since the Unix Epoch\nremoveState() Remove the state from the persistence store\n\nimport { createStore } from 'https://cdn.skypack.dev/ficusjs'\n\nclass MyCustomPersist {\n  setState (state) {\n    // set the state\n  }\n\n  getState () {\n    // get the state\n  }\n\n  lastUpdated () {\n    // get the last updated time in milliseconds since the Unix Epoch\n  }\n\n  removeState () {\n    // remove the state - this is called by default when setState is null\n  }\n}\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  persist: new MyCustomPersist()\n})\n\nUsage in components\n\nOnce you have created your store instance, the withStore function extends a component and makes working with stores easier in component rendering, computed getters and methods.\nSubscription to store changes will be handled automatically within the component.\n\nSee extending components for more on the withStore function.\n\nimport { createCustomElement, withStore } from 'https://cdn.skypack.dev/ficusjs@6'\nimport { html, renderer } from 'https://cdn.skypack.dev/@ficusjs/renderers@5/lit-html'\n\n// An initialised store. Params omitted for brevity\nconst store = createStore('an.example.store', {\n  ...\n})\n\n// A new component\ncreateCustomElement(\n  'my-component',\n  withStore(store, {\n    ...\n  })\n)"},"testing.md":{"id":"testing.md","title":"Testing","url":"/testing/","excerpt":"Testing\n\nThe FicusJS testing package provides lightweight helper functions for web component testing.\n\nThis package provides...","body":"Testing\n\nThe FicusJS testing package provides lightweight helper functions for web component testing.\n\nThis package provides browser globals such as window and document using jsdom which is an implementation of many browser APIs ideal for testing but is not an actual browser.\n\nWe recommend using a tool such as Cypress for browser end-to-end tests.\n\nRunning tests\n\nThis package contains functions intended for a NodeJS environment and not a real browser. It is therefore, best used for fast iteration.\n\nThe functions can be used with any NodeJS testing framework.\n\nThe following functions are available in the FicusJS testing package.\n\ninit - a function for initializing the test environment\nrender - a function to render a web component for testing\n\ninit function\n\nThe init function initializes the NodeJS environment ready for testing.\n\nSimply call init in your set-up hook.\n\nimport test from 'ava'\nimport { init, render } from '@ficusjs/testing'\n\ntest.before(init)\n\n// if passing options to JSDOM\ntest.before(() => init({ runScripts: 'dangerously' }))\n\nThe init function accepts the following optional arguments:\n\nName Type Description\noptions object An object of options to pass to JSDOM\n\nrender function\n\nThe render function will create a new web component instance for testing.\n\nIt returns a DOM instance of the component.\n\nimport test from 'ava'\nimport { init, render } from '@ficusjs/testing'\n\ntest.before(init)\n\ntest('render basic component', async t => {\n    const comp = await render('basic-comp', () => import('../src/component.mjs'))\n    t.is(comp.querySelector('p').textContent, 'Basic component')\n})\n\nThe render function accepts the following arguments:\n\nName Type Description\ntagName string The web component tag name\nimporter function A function that registers a web component. This can return a Promise\n\nTesting components\n\nTesting web components can be done in a number of ways.\n\nverifying that a component renders without throwing using a \"smoke test\"\nshallow rendering and testing component output\nfull rendering and testing component lifecycle and state changes\n\nIt is a good idea to start with creating basic smoke tests for your components.\n\nTesting that a component mounts and ensures that it doesn't throw during rendering provides a lot of value with very little effort."}}